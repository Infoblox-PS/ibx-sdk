{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Infoblox ibx-sdk","text":"<p>Welcome to the <code>ibx-sdk</code> for Infoblox Products. This library and SDK contains the following:</p> <ul> <li>Python wrapper for Infoblox NIOS Web RESTful API or WAPI</li> <li>Fully-functioning basic operational scripts &amp; tools</li> <li>Thorough documentation</li> </ul> <p>The <code>ibx-sdk</code> is a collection of Python classes and methods tailored for streamlined and effective interaction. This  SDK is developed with a focus on simplicity and efficiency, enabling users to perform a variety of API actions essential  for integrations with Infoblox Products.</p> <p>The <code>ibx-sdk</code> can accommodate users at different levels of expertise. It offers an intuitive interface for beginners, while still providing the robust functionality that experienced developers require. This SDK is an ideal solution for  automating network management tasks, ensuring seamless integration with diverse systems and workflows.</p> <p>This SDK contains several practical scripts and tools that illustrate the application of its methods in real-world  scenarios. The scripts are intended to provide users with a clear understanding of how the toolkit can be utilized to  its full potential, demonstrating its versatility and effectiveness in various use cases.</p> <p>We invite you to explore the capabilities of the <code>ibx-sdk</code> package. Our goal is to deliver an SDK that is not only reliable and efficient but also adaptable to the dynamic requirements of contemporary network environments.</p>"},{"location":"LICENSE/","title":"License","text":"<pre><code>                                 Apache License\n                           Version 2.0, January 2004\n                        https://www.apache.org/licenses/\n\nTERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n\n1. Definitions.\n\n   \"License\" shall mean the terms and conditions for use, reproduction,\n   and distribution as defined by Sections 1 through 9 of this document.\n\n   \"Licensor\" shall mean the copyright owner or entity authorized by\n   the copyright owner that is granting the License.\n\n   \"Legal Entity\" shall mean the union of the acting entity and all\n   other entities that control, are controlled by, or are under common\n   control with that entity. For the purposes of this definition,\n   \"control\" means (i) the power, direct or indirect, to cause the\n   direction or management of such entity, whether by contract or\n   otherwise, or (ii) ownership of fifty percent (50%) or more of the\n   outstanding shares, or (iii) beneficial ownership of such entity.\n\n   \"You\" (or \"Your\") shall mean an individual or Legal Entity\n   exercising permissions granted by this License.\n\n   \"Source\" form shall mean the preferred form for making modifications,\n   including but not limited to software source code, documentation\n   source, and configuration files.\n\n   \"Object\" form shall mean any form resulting from mechanical\n   transformation or translation of a Source form, including but\n   not limited to compiled object code, generated documentation,\n   and conversions to other media types.\n\n   \"Work\" shall mean the work of authorship, whether in Source or\n   Object form, made available under the License, as indicated by a\n   copyright notice that is included in or attached to the work\n   (an example is provided in the Appendix below).\n\n   \"Derivative Works\" shall mean any work, whether in Source or Object\n   form, that is based on (or derived from) the Work and for which the\n   editorial revisions, annotations, elaborations, or other modifications\n   represent, as a whole, an original work of authorship. For the purposes\n   of this License, Derivative Works shall not include works that remain\n   separable from, or merely link (or bind by name) to the interfaces of,\n   the Work and Derivative Works thereof.\n\n   \"Contribution\" shall mean any work of authorship, including\n   the original version of the Work and any modifications or additions\n   to that Work or Derivative Works thereof, that is intentionally\n   submitted to Licensor for inclusion in the Work by the copyright owner\n   or by an individual or Legal Entity authorized to submit on behalf of\n   the copyright owner. For the purposes of this definition, \"submitted\"\n   means any form of electronic, verbal, or written communication sent\n   to the Licensor or its representatives, including but not limited to\n   communication on electronic mailing lists, source code control systems,\n   and issue tracking systems that are managed by, or on behalf of, the\n   Licensor for the purpose of discussing and improving the Work, but\n   excluding communication that is conspicuously marked or otherwise\n   designated in writing by the copyright owner as \"Not a Contribution.\"\n\n   \"Contributor\" shall mean Licensor and any individual or Legal Entity\n   on behalf of whom a Contribution has been received by Licensor and\n   subsequently incorporated within the Work.\n\n2. Grant of Copyright License. Subject to the terms and conditions of\n   this License, each Contributor hereby grants to You a perpetual,\n   worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n   copyright license to reproduce, prepare Derivative Works of,\n   publicly display, publicly perform, sublicense, and distribute the\n   Work and such Derivative Works in Source or Object form.\n\n3. Grant of Patent License. Subject to the terms and conditions of\n   this License, each Contributor hereby grants to You a perpetual,\n   worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n   (except as stated in this section) patent license to make, have made,\n   use, offer to sell, sell, import, and otherwise transfer the Work,\n   where such license applies only to those patent claims licensable\n   by such Contributor that are necessarily infringed by their\n   Contribution(s) alone or by combination of their Contribution(s)\n   with the Work to which such Contribution(s) was submitted. If You\n   institute patent litigation against any entity (including a\n   cross-claim or counterclaim in a lawsuit) alleging that the Work\n   or a Contribution incorporated within the Work constitutes direct\n   or contributory patent infringement, then any patent licenses\n   granted to You under this License for that Work shall terminate\n   as of the date such litigation is filed.\n\n4. Redistribution. You may reproduce and distribute copies of the\n   Work or Derivative Works thereof in any medium, with or without\n   modifications, and in Source or Object form, provided that You\n   meet the following conditions:\n\n   (a) You must give any other recipients of the Work or\n   Derivative Works a copy of this License; and\n\n   (b) You must cause any modified files to carry prominent notices\n   stating that You changed the files; and\n\n   (c) You must retain, in the Source form of any Derivative Works\n   that You distribute, all copyright, patent, trademark, and\n   attribution notices from the Source form of the Work,\n   excluding those notices that do not pertain to any part of\n   the Derivative Works; and\n\n   (d) If the Work includes a \"NOTICE\" text file as part of its\n   distribution, then any Derivative Works that You distribute must\n   include a readable copy of the attribution notices contained\n   within such NOTICE file, excluding those notices that do not\n   pertain to any part of the Derivative Works, in at least one\n   of the following places: within a NOTICE text file distributed\n   as part of the Derivative Works; within the Source form or\n   documentation, if provided along with the Derivative Works; or,\n   within a display generated by the Derivative Works, if and\n   wherever such third-party notices normally appear. The contents\n   of the NOTICE file are for informational purposes only and\n   do not modify the License. You may add Your own attribution\n   notices within Derivative Works that You distribute, alongside\n   or as an addendum to the NOTICE text from the Work, provided\n   that such additional attribution notices cannot be construed\n   as modifying the License.\n\n   You may add Your own copyright statement to Your modifications and\n   may provide additional or different license terms and conditions\n   for use, reproduction, or distribution of Your modifications, or\n   for any such Derivative Works as a whole, provided Your use,\n   reproduction, and distribution of the Work otherwise complies with\n   the conditions stated in this License.\n\n5. Submission of Contributions. Unless You explicitly state otherwise,\n   any Contribution intentionally submitted for inclusion in the Work\n   by You to the Licensor shall be under the terms and conditions of\n   this License, without any additional terms or conditions.\n   Notwithstanding the above, nothing herein shall supersede or modify\n   the terms of any separate license agreement you may have executed\n   with Licensor regarding such Contributions.\n\n6. Trademarks. This License does not grant permission to use the trade\n   names, trademarks, service marks, or product names of the Licensor,\n   except as required for reasonable and customary use in describing the\n   origin of the Work and reproducing the content of the NOTICE file.\n\n7. Disclaimer of Warranty. Unless required by applicable law or\n   agreed to in writing, Licensor provides the Work (and each\n   Contributor provides its Contributions) on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n   implied, including, without limitation, any warranties or conditions\n   of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n   PARTICULAR PURPOSE. You are solely responsible for determining the\n   appropriateness of using or redistributing the Work and assume any\n   risks associated with Your exercise of permissions under this License.\n\n8. Limitation of Liability. In no event and under no legal theory,\n   whether in tort (including negligence), contract, or otherwise,\n   unless required by applicable law (such as deliberate and grossly\n   negligent acts) or agreed to in writing, shall any Contributor be\n   liable to You for damages, including any direct, indirect, special,\n   incidental, or consequential damages of any character arising as a\n   result of this License or out of the use or inability to use the\n   Work (including but not limited to damages for loss of goodwill,\n   work stoppage, computer failure or malfunction, or any and all\n   other commercial damages or losses), even if such Contributor\n   has been advised of the possibility of such damages.\n\n9. Accepting Warranty or Additional Liability. While redistributing\n   the Work or Derivative Works thereof, You may choose to offer,\n   and charge a fee for, acceptance of support, warranty, indemnity,\n   or other liability obligations and/or rights consistent with this\n   License. However, in accepting such obligations, You may act only\n   on Your own behalf and on Your sole responsibility, not on behalf\n   of any other Contributor, and only if You agree to indemnify,\n   defend, and hold each Contributor harmless for any liability\n   incurred by, or claims asserted against, such Contributor by reason\n   of your accepting any such warranty or additional liability.\n\nEND OF TERMS AND CONDITIONS\n</code></pre>"},{"location":"changelog/","title":"Change Log","text":""},{"location":"classes/nios/fileop/","title":"File Operations","text":"<p>Copyright 2023 Infoblox</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p> <pre><code>https://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>"},{"location":"classes/nios/fileop/#ibx_sdk.nios.fileop.NiosFileopMixin","title":"<code>NiosFileopMixin</code>","text":"<p>NiosFileopMixin class</p> Source code in <code>src/ibx_sdk/nios/fileop.py</code> <pre><code>class NiosFileopMixin:\n    \"\"\"\n    NiosFileopMixin class\n    \"\"\"\n\n    def csv_export(self, wapi_object: str, filename: Optional[str] = None) -&gt; None:\n        \"\"\"\n        Perform a NIOS CSV Export Task for a given WAPI object\n\n        Args:\n            wapi_object: The name of the WAPI object to perform a CSV export on.\n            filename: Optional. The name of the file to save the exported data to. If not\n                                provided, a default filename will be generated based on the\n                                download URL.\n\n        Raises:\n            requests.exceptions.RequestException: If there is an error in the request.\n\n        Returns:\n            None\n\n        \"\"\"\n        if filename:\n            (_, filename) = os.path.split(filename)\n            filename = os.path.join(_, filename.replace(\"-\", \"_\"))\n\n        # Call WAPI fileop  csv_export function\n        logging.info(\"performing csv export for %s object(s)\", wapi_object)\n        payload = {\"_object\": wapi_object}\n        try:\n            response = self.post(\n                \"fileop\", params={\"_function\": \"csv_export\"}, json=payload\n            )\n            logging.debug(response.text)\n            response.raise_for_status()\n        except requests.exceptions.RequestException as err:\n            logging.error(err)\n            raise WapiRequestException(err)\n\n        obj = response.json()\n        download_url = obj.get(\"url\")\n        download_token = obj.get(\"token\")\n\n        logging.info(\"downloading data from %s\", download_url)\n        response = self.__download_file(download_url, self.__get_cookies())\n\n        if not filename:\n            filename = util.extract_filename_from_url(download_url)\n\n        NiosFileopMixin.__write_file(filename=filename, data=response)\n\n        self.__download_complete(download_token, filename, self.__get_cookies())\n\n    def file_download(\n            self,\n            token: str,\n            url: str,\n            filename: str = None,\n    ) -&gt; None:\n        \"\"\"\n        file_download downloads the generated file from the NIOS Grid using a token and url\n\n        Args:\n            token: Authentication token required for the download completion.\n            url: URL of the file to be downloaded.\n            filename: Optional; name for the downloaded file. If not provided, it will be extracted from the URL.\n\n        Returns:\n            None\n        \"\"\"\n        logging.info(\"downloading data from %s\", url)\n        try:\n            res = self.__download_file(url, self.__get_cookies())\n        except requests.exceptions.RequestException as err:\n            logging.error(err)\n            raise WapiRequestException(err)\n\n        if not filename:\n            filename = util.extract_filename_from_url(url)\n\n        NiosFileopMixin.__write_file(filename=filename, data=res)\n\n        try:\n            self.__download_complete(token, filename, self.__get_cookies())\n        except requests.exceptions.RequestException as err:\n            logging.error(err)\n            raise WapiRequestException(err)\n\n    def file_upload(self, filename: str) -&gt; str:\n        \"\"\"\n        Perform a file upload into the NIOS Grid.\n\n        Args:\n            filename: The path of the file to be uploaded.\n\n        Returns:\n            str: The token received upon successful upload initialization.\n\n        Raises:\n            WapiRequestException: If there is a request exception during the upload process.\n        \"\"\"\n        (_, filename) = os.path.split(filename)\n        filename = filename.replace(\"-\", \"_\")\n\n        # Call WAPI fileop Upload INIT\n        logging.info(\"step 1 - request uploadinit %s\", filename)\n        try:\n            obj = self.__upload_init(filename=filename)\n        except requests.exceptions.RequestException as err:\n            logging.error(err)\n            raise WapiRequestException(err)\n\n        upload_url = obj.get(\"url\")\n        token = obj.get(\"token\")\n\n        # specify a file handle for the file data to be uploaded\n        with open(filename, \"rb\") as csvfile:\n            # reset to top of the file\n            csvfile.seek(0)\n            upload_file = {\"file\": csvfile.read()}\n\n            # Upload the contents of the CSV file\n            logging.info(\"step 2 - post the files using the upload_url provided\")\n            try:\n                self.__upload_file(upload_url, upload_file, self.__get_cookies())\n            except requests.exceptions.RequestException as err:\n                logging.error(err)\n                raise WapiRequestException(err)\n            else:\n                return token\n\n    def upload_certificate(\n            self,\n            member: str,\n            filename: str,\n            certificate_usage: SupportedCertTypes = \"ADMIN\",\n    ):\n        \"\"\"\n        Upload an SSL Certificate file to the Grid\n\n        Args:\n            member: The member identifier to which the certificate will be uploaded.\n            filename: The filename of the certificate to be uploaded.\n            certificate_usage: The usage type of the certificate. Default is \"ADMIN\".\n\n        Raises:\n            WapiRequestException: If there is an error during the request to upload the certificate.\n        \"\"\"\n        token = self.file_upload(filename=filename)\n\n        # submit task to CSV Job Manager\n        logging.info(\"step 3 - upload %s certificate on %s\", certificate_usage, member)\n        payload = {\"certificate_usage\": certificate_usage, \"member\": member, \"token\": token}\n        try:\n            res = self.post(\n                \"fileop\",\n                params={\"_function\": \"uploadcertificate\"},\n                json=payload,\n                cookies=self.__get_cookies(),\n            )\n            logging.debug(pprint.pformat(res.text))\n            res.raise_for_status()\n        except requests.exceptions.RequestException as err:\n            logging.error(err)\n            raise WapiRequestException(err)\n\n    def csv_import(\n            self,\n            task_operation: CsvOperation,\n            csv_import_file: str,\n            exit_on_error: bool = False,\n    ) -&gt; dict:\n        \"\"\"\n        Perform a CSV import task using the NIOS CSV Task Manager\n\n        Args:\n            task_operation (CsvOperation): The operation to be performed on the CSV file. Should be\n                                           a value from the `CsvOperation` enum.\n            csv_import_file (str): The path to the CSV file to be imported.\n            exit_on_error (bool): Indicates whether the program should exit if an error occurs\n                                  during the import process. Default value is `False`.\n\n        Returns:\n            A dictionary containing the result of the CSV import task.\n\n        Raises:\n            requests.exceptions.RequestException: If an error occurs while making HTTP requests.\n        \"\"\"\n        token = self.file_upload(filename=csv_import_file)\n\n        # submit task to CSV Job Manager\n        logging.info(\n            \"step 3 - execute the csv_import %s job on %s\",\n            task_operation,\n            csv_import_file,\n        )\n        try:\n            csvtask = self.__csv_import(\n                task_operation.upper(), token, self.__get_cookies(), exit_on_error\n            )\n        except requests.exceptions.RequestException as err:\n            logging.error(err)\n            raise WapiRequestException(err)\n        else:\n            return csvtask\n\n    def csvtask_status(self, csvtask: dict) -&gt; dict:\n        \"\"\"\n        Fetch the status of a CSV submitted task\n\n        Args:\n            csvtask (dict): The dictionary containing the information about the CSV import task.\n\n        Returns:\n            dict: The JSON response containing the status of the CSV import task.\n\n        Raises:\n            RequestException: If there is an error in the request.\n\n        Description:\n            This method is used to check the status of a CSV import task. It takes a dictionary,\n            `csvtask`, as input, which contains the information about the CSV import task. The\n            `csvtask` dictionary should have the following structure:\n\n            {\n                'csv_import_task': {\n                    '_ref': '&lt;CSV import task reference&gt;'\n                }\n            }\n\n            The method first retrieves the `_ref` value from the `csvtask` dictionary to identify\n            the import task. It then sends a request to retrieve the status of the import task\n            using the `get` method.\n\n            If the status request is successful, the JSON response containing the status is\n            logged using the `debug` level.\n\n            Finally, the method returns the JSON response containing the status of the CSV import\n            task.\n\n            If there is any error in the request, a `RequestException` is raised and logged using\n            the `error` level.\n\n        Example usage:\n\n        ```python\n        csvtask = {\n            'csv_import_task': {\n                '_ref': '12345678'\n            }\n        }\n        status = csvtask_status(csvtask)\n        ```\n        \"\"\"\n        _ref = csvtask[\"csv_import_task\"][\"_ref\"]\n        logging.debug(\"Checking status of csvimporttask %s\", _ref)\n        try:\n            res = self.get(_ref)\n            res.raise_for_status()\n        except requests.exceptions.RequestException as err:\n            logging.error(err)\n            raise WapiRequestException(err)\n        else:\n            logging.debug(res.json())\n\n        return res.json()\n\n    def get_csv_errors_file(self, filename: str, job_id: str) -&gt; None:\n        \"\"\"\n        Fetches the csv-errors file for a specific job ID.\n\n        Args:\n            filename (str): The filename to be used when saving the csv-errors file.\n            job_id (str): The job ID for which the csv-errors file should be fetched.\n\n        Returns:\n            None\n\n        Raises:\n            requests.exceptions.RequestException: If there is an error during the request.\n\n        \"\"\"\n        logging.debug(\"fetching csv-errors file for job id %s\", job_id)\n        payload = {\"import_id\": job_id}\n        try:\n            res = self.post(\n                \"fileop\", params={\"_function\": \"csv_error_log\"}, json=payload\n            )\n            logging.debug(pprint.pformat(res.text))\n            res.raise_for_status()\n        except requests.exceptions.RequestException as err:\n            logging.error(err)\n            raise WapiRequestException(err)\n\n        obj = res.json()\n        token = obj.get(\"token\")\n        download_url = obj.get(\"url\")\n\n        try:\n            res = self.__download_file(download_url, self.__get_cookies())\n            res.raise_for_status()\n        except requests.exceptions.RequestException as err:\n            logging.error(err)\n            raise WapiRequestException(err)\n\n        csv_error_file = f\"csv-errors-{filename}.csv\"\n        NiosFileopMixin.__write_file(filename=csv_error_file, data=res)\n\n        # We're done - so post to downloadcomplete function\n        try:\n            self.__download_complete(token, csv_error_file, self.__get_cookies())\n        except requests.exceptions.RequestException as err:\n            logging.error(err)\n            raise WapiRequestException(err)\n\n    def download_certificate(\n            self,\n            member: str,\n            certificate_usage: SupportedCertTypes = \"ADMIN\",\n    ):\n        \"\"\"\n        Download SSL certificate from the Grid.\n\n        Args:\n            member: The identifier of the member for whom the certificate is being downloaded.\n            certificate_usage: The type of certificate to be downloaded (e.g., \"ADMIN\").\n        \"\"\"\n        logging.info(\"Downloading %s certificate for %s\", certificate_usage, member)\n        payload = {\"member\": member, \"certificate_usage\": certificate_usage}\n        logging.debug(\"json payload %s\", payload)\n\n        try:\n            res = self.post(\"fileop\", params={\"_function\": \"downloadcertificate\"}, json=payload)\n            logging.debug(res.text)\n            res.raise_for_status()\n        except requests.exceptions.RequestException as err:\n            logging.error(err)\n            raise WapiRequestException(err)\n\n        obj = res.json()\n        download_url = obj.get(\"url\")\n        download_token = obj.get(\"token\")\n\n        self.file_download(token=download_token, url=download_url)\n\n    def generate_selfsigned_cert(\n            self,\n            cn: str,\n            member: str,\n            days_valid: int = 365,\n            algorithm: SupportedAlgorithms = \"SHA-256\",\n            certificate_usage: SupportedCertUsages = \"ADMIN\",\n            comment: Optional[str] = None,\n            country: Optional[str] = None,\n            email: Optional[str] = None,\n            key_size: Optional[SupportedKeySizes] = 2048,\n            locality: Optional[str] = None,\n            org: Optional[str] = None,\n            org_unit: Optional[str] = None,\n            state: Optional[str] = None,\n            subject_alternative_names: Optional[list[dict]] = None\n    ):\n        \"\"\"\n        Generate a Self-Signed Certificate on the Grid.\n\n        Args:\n            cn: The common name for the certificate.\n            member: The member name for the certificate.\n            days_valid: The number of days the certificate is valid for. Default is 365.\n            algorithm: The algorithm used for certificate generation. Default is \"SHA-256\".\n            certificate_usage: The usage type of the certificate. Default is \"ADMIN\".\n            comment: Optional comment associated with the certificate.\n            country: Optional country code.\n            email: Optional email address.\n            key_size: The size of the key used in certificate generation. Default is 2048.\n            locality: Optional locality (e.g., city).\n            org: Optional organization name.\n            org_unit: Optional organizational unit.\n            state: Optional state or province.\n            subject_alternative_names: Optional list of subject alternative names.\n\n        \"\"\"\n        logging.info(\"generating self-signed certificate for %s\", member)\n        payload = {\n            \"cn\": cn,\n            \"member\": member,\n            \"algorithm\": algorithm,\n            \"certificate_usage\": certificate_usage,\n            \"days_valid\": days_valid,\n        }\n        if comment:\n            payload[\"comment\"] = comment\n        if country:\n            payload[\"country\"] = country\n        if email:\n            payload[\"email\"] = email\n        if key_size:\n            payload[\"key_size\"] = key_size\n        if locality:\n            payload[\"locality\"] = locality\n        if org:\n            payload[\"org\"] = org\n        if org_unit:\n            payload[\"org_unit\"] = org_unit\n        if state:\n            payload[\"state\"] = state\n        if subject_alternative_names:\n            payload[\"subject_alternative_names\"] = subject_alternative_names\n        logging.debug(\"json payload %s\", payload)\n\n        try:\n            res = self.post(\n                \"fileop\", params={\"_function\": \"generateselfsignedcert\"}, json=payload\n            )\n            logging.debug(res.text)\n            res.raise_for_status()\n        except requests.exceptions.RequestException as err:\n            logging.error(err)\n            raise WapiRequestException(err)\n\n        obj = res.json()\n        download_url = obj.get(\"url\")\n        download_token = obj.get(\"token\")\n\n        self.file_download(token=download_token, url=download_url)\n\n    def generate_csr(\n            self,\n            cn: str,\n            member: str,\n            algorithm: SupportedAlgorithms = \"SHA-256\",\n            certificate_usage: SupportedCertUsages = \"ADMIN\",\n            comment: Optional[str] = None,\n            country: Optional[str] = None,\n            email: Optional[str] = None,\n            key_size: Optional[SupportedKeySizes] = 2048,\n            locality: Optional[str] = None,\n            org: Optional[str] = None,\n            org_unit: Optional[str] = None,\n            state: Optional[str] = None,\n            subject_alternative_names: Optional[list[dict]] = None\n    ) -&gt; None:\n        \"\"\"\n        Generate a Certificate Signing Request\n\n        Generate and download a CSR for a member of the grid. Once the CSR is generated it is downloaded and saved\n        locally to the current working directory.\n\n        Args:\n            cn: Common Name for the certificate.\n            member: The member for which the certificate is being generated.\n            algorithm: Algorithm used for certificate generation, default is \"SHA-256\".\n            certificate_usage: Purpose of the certificate, default is \"ADMIN\".\n            comment: Optional comment for the certificate.\n            country: Optional country code for the certificate.\n            email: Optional email address for the certificate.\n            key_size: Optional key size for the certificate, default is 2048.\n            locality: Optional locality or city for the certificate.\n            org: Optional organization name for the certificate.\n            org_unit: Optional organizational unit for the certificate.\n            state: Optional state or province for the certificate.\n            subject_alternative_names: Optional list of subject alternative names (SANs) for the certificate.\n\n        Returns:\n            None\n        \"\"\"\n        logging.info(\"generating %s csr for %s\", certificate_usage, member)\n        payload = {\n            \"cn\": cn,\n            \"member\": member,\n            \"algorithm\": algorithm,\n            \"certificate_usage\": certificate_usage,\n        }\n        if comment:\n            payload[\"comment\"] = comment\n        if country:\n            payload[\"country\"] = country\n        if email:\n            payload[\"email\"] = email\n        if key_size:\n            payload[\"key_size\"] = key_size\n        if locality:\n            payload[\"locality\"] = locality\n        if org:\n            payload[\"org\"] = org\n        if org_unit:\n            payload[\"org_unit\"] = org_unit\n        if state:\n            payload[\"state\"] = state\n        if subject_alternative_names:\n            payload[\"subject_alternative_names\"] = subject_alternative_names\n        logging.debug(\"json payload %s\", payload)\n\n        try:\n            res = self.post(\n                \"fileop\", params={\"_function\": \"generatecsr\"}, json=payload\n            )\n            logging.debug(res.text)\n            res.raise_for_status()\n        except requests.exceptions.RequestException as err:\n            logging.error(err)\n            raise WapiRequestException(err)\n\n        obj = res.json()\n        download_url = obj.get(\"url\")\n        download_token = obj.get(\"token\")\n\n        self.file_download(token=download_token, url=download_url)\n\n    def get_log_files(\n            self,\n            log_type: LogType,\n            filename: Optional[str] = None,\n            endpoint: Optional[str] = None,\n            include_rotated: bool = False,\n            member: Optional[str] = None,\n            msserver: Optional[str] = None,\n            node_type: Optional[Literal[\"ACTIVE\", \"BACKUP\"]] = None,\n    ):\n        \"\"\"\n        Fetch the log files for the provided member or msserver\n\n        Args:\n            log_type (LogType): The type of log files to fetch.\n            filename (str): The name of the log file to download (Default value = None)\n            endpoint (str): The specific endpoint for which to fetch log files. (Default: None)\n            include_rotated (bool): Whether to include rotated log files. (Default: False)\n            member (str): The member for which to fetch log files. (Default: None)\n            msserver (str): The msserver for which to fetch log files. (Default: None)\n            node_type: The type of node for which to fetch log files. Can be 'ACTIVE' or\n                       'BACKUP'. (Default: None)\n        \"\"\"\n        logging.info(\"fetching %s log files for %s\", log_type, member)\n        payload = {\"log_type\": log_type, \"include_rotated\": include_rotated}\n\n        if endpoint:\n            payload[\"endpoint\"] = endpoint\n        if member:\n            payload[\"member\"] = member\n        if node_type:\n            payload[\"node_type\"] = node_type\n        if msserver:\n            payload[\"msserver\"] = msserver\n\n        logging.debug(\"json payload %s\", payload)\n\n        try:\n            res = self.post(\n                \"fileop\", params={\"_function\": \"get_log_files\"}, json=payload\n            )\n            logging.debug(res.text)\n            res.raise_for_status()\n        except requests.exceptions.RequestException as err:\n            logging.error(err)\n            raise WapiRequestException(err)\n\n        obj = res.json()\n        download_url = obj.get(\"url\")\n        download_token = obj.get(\"token\")\n\n        self.file_download(token=download_token, url=download_url, filename=filename)\n\n    def get_support_bundle(\n            self,\n            member: str,\n            filename: Optional[str] = None,\n            cached_zone_data: bool = False,\n            core_files: bool = False,\n            log_files: bool = False,\n            nm_snmp_logs: bool = False,\n            recursive_cache_file: bool = False,\n            remote_url: Optional[str] = None,\n            rotate_log_files: bool = False,\n    ):\n        \"\"\"\n        Get the support bundle for a member.\n\n        Args:\n            member (str): The member for which to retrieve the support bundle.\n            filename (str, optional): The filename of the support bundle.\n            cached_zone_data (bool, optional): Whether to include cached zone data in the support\n                                               bundle. Defaults to False.\n            core_files (bool, optional): Whether to include core files in the support bundle.\n                                         Defaults to False.\n            log_files (bool, optional): Whether to include log files in the support bundle.\n                                        Defaults to False.\n            nm_snmp_logs (bool, optional): Whether to include NM SNMP logs in the support bundle.\n                                           Defaults to False.\n            recursive_cache_file (bool, optional): Whether to include recursive cache file in the\n                                                   support bundle. Defaults to False.\n            remote_url (str, optional): The remote URL where the support bundle will be uploaded.\n                                        Defaults to None.\n            rotate_log_files (bool, optional): Whether to rotate log files before creating the\n                                               support bundle. Defaults to False.\n\n        Raises:\n            requests.exceptions.RequestException: If an error occurs during the request.\n\n        \"\"\"\n        logging.info(\"performing get_support_bundle for %s object(s)\", member)\n        payload = {\n            \"member\": member,\n            \"cached_zone_data\": cached_zone_data,\n            \"core_files\": core_files,\n            \"log_files\": log_files,\n            \"nm_snmp_logs\": nm_snmp_logs,\n            \"recursive_cache_file\": recursive_cache_file,\n            \"rotate_log_files\": rotate_log_files,\n        }\n        if remote_url:\n            payload[\"remote_url\"] = remote_url\n        logging.debug(pprint.pformat(payload))\n        try:\n            res = self.post(\n                \"fileop\", params={\"_function\": \"get_support_bundle\"}, json=payload\n            )\n            logging.debug(res.text)\n            res.raise_for_status()\n        except requests.exceptions.RequestException as err:\n            logging.error(err)\n            raise WapiRequestException(err)\n\n        obj = res.json()\n        download_url = obj.get(\"url\")\n        download_token = obj.get(\"token\")\n\n        self.file_download(token=download_token, url=download_url, filename=filename)\n\n    def grid_backup(self, filename: Optional[str] = None) -&gt; None:\n        \"\"\"\n        Perform a NIOS Grid Backup.\n\n        Args:\n            filename: str, optional. The name of the backup file. Default is 'database.tgz'.\n\n        Returns:\n            None\n\n        Raises:\n            requests.exceptions.RequestException: If an error occurs during the backup process.\n        \"\"\"\n        payload = {\"type\": \"BACKUP\"}\n\n        logging.info(\"step 1 - request gridbackup %s\", filename)\n        try:\n            res = self.__getgriddata(payload, self.__get_cookies())\n        except requests.exceptions.RequestException as err:\n            logging.error(err)\n            raise WapiRequestException(err)\n\n        token = res.get(\"token\")\n        download_url = res.get(\"url\")\n\n        logging.info(\"step 2 - saving backup to %s\", filename)\n        self.file_download(token=token, url=download_url, filename=filename)\n\n    def grid_restore(\n            self,\n            filename: str = \"database.tgz\",\n            mode: GridRestoreMode = \"NORMAL\",\n            keep_grid_ip: bool = False,\n    ):\n        \"\"\"\n        Perform a NIOS Grid restore of a database using a given file.\n\n        Args:\n            filename (str): The filename of the database file to be restored. Default is\n                            \"database.tgz\".\n            mode (GridRestoreMode): The restore mode to be used. Default is \"NORMAL\".\n            keep_grid_ip (bool): Indicates whether to keep the grid IP address. Default is False.\n\n        \"\"\"\n        token = self.file_upload(filename=filename)\n\n        # Execute the restore\n        logging.info(\"step 4 - execute the grid restore\")\n        try:\n            self.__restore_database(keep_grid_ip, mode, token, self.__get_cookies())\n        except requests.exceptions.RequestException as err:\n            logging.error(\"step 4 - Error: %s\", err)\n            raise WapiRequestException(err)\n        logging.info(\"Grid restore successful!\")\n\n    def member_config(\n            self,\n            member: str,\n            conf_type: MemberDataType,\n            filename: Optional[str] = None,\n            remote_url: str = None,\n    ) -&gt; None:\n        \"\"\"\n        Fetch member configuration file for given service type.\n\n        Args:\n            member: A string representing the grid member.\n            conf_type: An enum representing the type of config file.\n            filename: A string value of the filename to save\n            remote_url: An optional string representing the remote URL.\n\n        Returns:\n            A string representing the downloaded file.\n\n        \"\"\"\n        conf_type = conf_type.upper()\n        logging.info(\"fetching %s config file for grid member %s\", conf_type, member)\n        payload = {\"member\": member, \"type\": conf_type}\n        if remote_url:\n            payload[\"remote_url\"] = remote_url\n        try:\n            res = self.post(\n                \"fileop\", params={\"_function\": \"getmemberdata\"}, json=payload\n            )\n            logging.debug(res.text)\n            res.raise_for_status()\n        except requests.exceptions.RequestException as err:\n            logging.error(err)\n            raise WapiRequestException(err)\n\n        obj = res.json()\n        download_url = obj.get(\"url\")\n        download_token = obj.get(\"token\")\n\n        self.file_download(token=download_token, url=download_url, filename=filename)\n\n    def get_lease_history(\n            self,\n            member: str,\n            start_time: int = None,\n            end_time: int = None,\n            remove_url: str = None\n    ) -&gt; None:\n        \"\"\"\n        fetch DHCP lease history files from a NIOS Grid Member\n\n        Args:\n            member: A string representing the grid member that the DHCP lease history is being fetched from.\n            start_time: An optional integer representing the start time in epoch format. Defaults to None.\n            end_time: An optional integer representing the end time in epoch format. Defaults to None.\n            remove_url: An optional string representing the remove URL. Defaults to None.\n\n        Returns:\n            A string representing the filename of the downloaded DHCP lease history file.\n\n        Raises:\n            WapiRequestException: If there is an error in the API request.\n\n        \"\"\"\n        logging.info(\"fetching DHCP lease history from grid member %s\", member)\n        payload = {\"member\": member}\n        if start_time is not None:\n            payload[\"start_time\"] = start_time\n        if end_time is not None:\n            payload[\"end_time\"] = end_time\n        if remove_url is not None:\n            payload[\"remove_url\"] = remove_url\n        try:\n            res = self.post(\n                \"fileop\", params={\"_function\": \"getleasehistoryfiles\"}, json=payload\n            )\n            logging.debug(res.text)\n            res.raise_for_status()\n        except requests.exceptions.RequestException as err:\n            logging.error(err)\n            raise WapiRequestException(err)\n\n        obj = res.json()\n        download_url = obj.get(\"url\")\n        download_token = obj.get(\"token\")\n\n        self.file_download(token=download_token, url=download_url)\n\n    def __csv_import(\n            self,\n            task_operation: str,\n            upload_token: str,\n            req_cookies: dict,\n            exit_on_error: bool = False,\n    ) -&gt; dict:\n        headers = {\"content-type\": \"application/json\"}\n\n        # set the request parameters\n        payload = {\n            \"action\": \"START\",\n            \"doimport\": True,\n            \"on_error\": \"STOP\" if exit_on_error else \"CONTINUE\",\n            \"operation\": task_operation,\n            \"separator\": \"COMMA\",\n            \"token\": upload_token,\n        }\n\n        # Update the operation if the user passes in MERGE or OVERRIDE directly\n        if task_operation == \"MERGE\":\n            payload[\"operation\"] = \"UPDATE\"\n            payload[\"update_method\"] = \"MERGE\"\n        elif task_operation == \"OVERRIDE\":\n            payload[\"operation\"] = \"UPDATE\"\n            payload[\"update_method\"] = \"OVERRIDE\"\n\n        # start the CSV task in job manager\n        try:\n            res = self.post(\n                \"fileop\",\n                params={\"_function\": \"csv_import\"},\n                json=payload,\n                headers=headers,\n                cookies=req_cookies,\n            )\n            logging.debug(pprint.pformat(res.text))\n            res.raise_for_status()\n        except requests.exceptions.RequestException as err:\n            logging.error(err)\n            raise WapiRequestException(err)\n\n        return res.json()\n\n    def __download_complete(self, token: str, filename: str, req_cookies: dict) -&gt; None:\n        header = {\"Content-type\": \"application/json\"}\n        payload = {\"token\": token}\n        try:\n            res = self.post(\n                \"fileop\",\n                params={\"_function\": \"downloadcomplete\"},\n                json=payload,\n                headers=header,\n                cookies=req_cookies,\n            )\n            logging.info(\"file %s download complete\", filename)\n            res.raise_for_status()\n        except requests.exceptions.RequestException as err:\n            logging.error(err)\n\n    def __download_file(self, download_url, req_cookies):\n        header = {\"Content-type\": \"application/force-download\"}\n        res = None\n        try:\n            logging.info(download_url)\n            res = self.conn.get(\n                download_url,\n                headers=header,\n                stream=True,\n                cookies=req_cookies,\n                verify=self.ssl_verify,\n            )\n            res.raise_for_status()\n        except requests.exceptions.RequestException as err:\n            logging.error(err)\n        return res\n\n    def __getgriddata(self, payload: dict, req_cookies) -&gt; dict:\n        headers = {\"content-type\": \"application/json\"}\n        try:\n            res = self.post(\n                \"fileop\",\n                params={\"_function\": \"getgriddata\"},\n                json=payload,\n                headers=headers,\n                cookies=req_cookies,\n            )\n            logging.debug(pprint.pformat(res.text))\n            res.raise_for_status()\n        except requests.exceptions.RequestException as err:\n            logging.error(err)\n            raise WapiRequestException(err)\n\n        return res.json()\n\n    def __restore_database(\n            self, keep_grid_ip: bool, mode: str, upload_token: str, req_cookies: dict\n    ) -&gt; dict:\n        # set content type back to JSON\n        headers = {\"content-type\": \"application/json\"}\n\n        # set the request parameters\n        payload = {\"keep_grid_ip\": keep_grid_ip, \"mode\": mode, \"token\": upload_token}\n\n        # start the restore\n        try:\n            res = self.post(\n                \"fileop\",\n                params={\"_function\": \"restoredatabase\"},\n                json=payload,\n                headers=headers,\n                cookies=req_cookies,\n            )\n            logging.debug(pprint.pformat(res.text))\n            res.raise_for_status()\n        except requests.exceptions.RequestException as err:\n            logging.error(err)\n            raise WapiRequestException(err)\n        return res\n\n    def __upload_file(\n            self, upload_url: str, upload_file: dict, req_cookies: dict\n    ) -&gt; None:\n        logging.debug(upload_url)\n        try:\n            res = self.conn.post(\n                upload_url,\n                files=upload_file,\n                cookies=req_cookies,\n                verify=self.ssl_verify,\n            )\n            logging.debug(pprint.pformat(res.text))\n            res.raise_for_status()\n        except requests.exceptions.RequestException as err:\n            logging.error(err)\n            raise WapiRequestException(err)\n\n    def __upload_init(self, filename: str) -&gt; dict:\n        headers = {\"content-type\": \"application/json\"}\n        payload = {\"filename\": filename}\n        try:\n            res = self.post(\n                \"fileop\",\n                params={\"_function\": \"uploadinit\"},\n                headers=headers,\n                json=payload,\n            )\n            logging.debug(pprint.pformat(res.text))\n            res.raise_for_status()\n        except requests.exceptions.RequestException as err:\n            logging.error(err)\n            raise WapiRequestException(err)\n\n        return res.json()\n\n    def __get_cookies(self) -&gt; dict:\n        # save the authentication cookie for use in subsequent requests\n        ibapauth_cookie = self.conn.cookies[\"ibapauth\"]\n        return {\"ibapauth\": ibapauth_cookie}\n\n    @staticmethod\n    def __write_file(filename: str, data: requests.Response) -&gt; None:\n        logging.info(\"writing file: %s\", filename)\n        with open(filename, \"wb\") as file:\n            for chunk in data.iter_content(chunk_size=1024):\n                if chunk:\n                    file.write(chunk)\n</code></pre>"},{"location":"classes/nios/fileop/#ibx_sdk.nios.fileop.NiosFileopMixin.csv_export","title":"<code>csv_export(wapi_object, filename=None)</code>","text":"<p>Perform a NIOS CSV Export Task for a given WAPI object</p> <p>Parameters:</p> Name Type Description Default <code>wapi_object</code> <code>str</code> <p>The name of the WAPI object to perform a CSV export on.</p> required <code>filename</code> <code>Optional[str]</code> <p>Optional. The name of the file to save the exported data to. If not                 provided, a default filename will be generated based on the                 download URL.</p> <code>None</code> <p>Raises:</p> Type Description <code>RequestException</code> <p>If there is an error in the request.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/ibx_sdk/nios/fileop.py</code> <pre><code>def csv_export(self, wapi_object: str, filename: Optional[str] = None) -&gt; None:\n    \"\"\"\n    Perform a NIOS CSV Export Task for a given WAPI object\n\n    Args:\n        wapi_object: The name of the WAPI object to perform a CSV export on.\n        filename: Optional. The name of the file to save the exported data to. If not\n                            provided, a default filename will be generated based on the\n                            download URL.\n\n    Raises:\n        requests.exceptions.RequestException: If there is an error in the request.\n\n    Returns:\n        None\n\n    \"\"\"\n    if filename:\n        (_, filename) = os.path.split(filename)\n        filename = os.path.join(_, filename.replace(\"-\", \"_\"))\n\n    # Call WAPI fileop  csv_export function\n    logging.info(\"performing csv export for %s object(s)\", wapi_object)\n    payload = {\"_object\": wapi_object}\n    try:\n        response = self.post(\n            \"fileop\", params={\"_function\": \"csv_export\"}, json=payload\n        )\n        logging.debug(response.text)\n        response.raise_for_status()\n    except requests.exceptions.RequestException as err:\n        logging.error(err)\n        raise WapiRequestException(err)\n\n    obj = response.json()\n    download_url = obj.get(\"url\")\n    download_token = obj.get(\"token\")\n\n    logging.info(\"downloading data from %s\", download_url)\n    response = self.__download_file(download_url, self.__get_cookies())\n\n    if not filename:\n        filename = util.extract_filename_from_url(download_url)\n\n    NiosFileopMixin.__write_file(filename=filename, data=response)\n\n    self.__download_complete(download_token, filename, self.__get_cookies())\n</code></pre>"},{"location":"classes/nios/fileop/#ibx_sdk.nios.fileop.NiosFileopMixin.csv_import","title":"<code>csv_import(task_operation, csv_import_file, exit_on_error=False)</code>","text":"<p>Perform a CSV import task using the NIOS CSV Task Manager</p> <p>Parameters:</p> Name Type Description Default <code>task_operation</code> <code>CsvOperation</code> <p>The operation to be performed on the CSV file. Should be                            a value from the <code>CsvOperation</code> enum.</p> required <code>csv_import_file</code> <code>str</code> <p>The path to the CSV file to be imported.</p> required <code>exit_on_error</code> <code>bool</code> <p>Indicates whether the program should exit if an error occurs                   during the import process. Default value is <code>False</code>.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary containing the result of the CSV import task.</p> <p>Raises:</p> Type Description <code>RequestException</code> <p>If an error occurs while making HTTP requests.</p> Source code in <code>src/ibx_sdk/nios/fileop.py</code> <pre><code>def csv_import(\n        self,\n        task_operation: CsvOperation,\n        csv_import_file: str,\n        exit_on_error: bool = False,\n) -&gt; dict:\n    \"\"\"\n    Perform a CSV import task using the NIOS CSV Task Manager\n\n    Args:\n        task_operation (CsvOperation): The operation to be performed on the CSV file. Should be\n                                       a value from the `CsvOperation` enum.\n        csv_import_file (str): The path to the CSV file to be imported.\n        exit_on_error (bool): Indicates whether the program should exit if an error occurs\n                              during the import process. Default value is `False`.\n\n    Returns:\n        A dictionary containing the result of the CSV import task.\n\n    Raises:\n        requests.exceptions.RequestException: If an error occurs while making HTTP requests.\n    \"\"\"\n    token = self.file_upload(filename=csv_import_file)\n\n    # submit task to CSV Job Manager\n    logging.info(\n        \"step 3 - execute the csv_import %s job on %s\",\n        task_operation,\n        csv_import_file,\n    )\n    try:\n        csvtask = self.__csv_import(\n            task_operation.upper(), token, self.__get_cookies(), exit_on_error\n        )\n    except requests.exceptions.RequestException as err:\n        logging.error(err)\n        raise WapiRequestException(err)\n    else:\n        return csvtask\n</code></pre>"},{"location":"classes/nios/fileop/#ibx_sdk.nios.fileop.NiosFileopMixin.csvtask_status","title":"<code>csvtask_status(csvtask)</code>","text":"<p>Fetch the status of a CSV submitted task</p> <p>Parameters:</p> Name Type Description Default <code>csvtask</code> <code>dict</code> <p>The dictionary containing the information about the CSV import task.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The JSON response containing the status of the CSV import task.</p> <p>Raises:</p> Type Description <code>RequestException</code> <p>If there is an error in the request.</p> Description <p>This method is used to check the status of a CSV import task. It takes a dictionary, <code>csvtask</code>, as input, which contains the information about the CSV import task. The <code>csvtask</code> dictionary should have the following structure:</p> <p>{     'csv_import_task': {         '_ref': ''     } } <p>The method first retrieves the <code>_ref</code> value from the <code>csvtask</code> dictionary to identify the import task. It then sends a request to retrieve the status of the import task using the <code>get</code> method.</p> <p>If the status request is successful, the JSON response containing the status is logged using the <code>debug</code> level.</p> <p>Finally, the method returns the JSON response containing the status of the CSV import task.</p> <p>If there is any error in the request, a <code>RequestException</code> is raised and logged using the <code>error</code> level.</p> <p>Example usage:</p> <pre><code>csvtask = {\n    'csv_import_task': {\n        '_ref': '12345678'\n    }\n}\nstatus = csvtask_status(csvtask)\n</code></pre> Source code in <code>src/ibx_sdk/nios/fileop.py</code> <pre><code>def csvtask_status(self, csvtask: dict) -&gt; dict:\n    \"\"\"\n    Fetch the status of a CSV submitted task\n\n    Args:\n        csvtask (dict): The dictionary containing the information about the CSV import task.\n\n    Returns:\n        dict: The JSON response containing the status of the CSV import task.\n\n    Raises:\n        RequestException: If there is an error in the request.\n\n    Description:\n        This method is used to check the status of a CSV import task. It takes a dictionary,\n        `csvtask`, as input, which contains the information about the CSV import task. The\n        `csvtask` dictionary should have the following structure:\n\n        {\n            'csv_import_task': {\n                '_ref': '&lt;CSV import task reference&gt;'\n            }\n        }\n\n        The method first retrieves the `_ref` value from the `csvtask` dictionary to identify\n        the import task. It then sends a request to retrieve the status of the import task\n        using the `get` method.\n\n        If the status request is successful, the JSON response containing the status is\n        logged using the `debug` level.\n\n        Finally, the method returns the JSON response containing the status of the CSV import\n        task.\n\n        If there is any error in the request, a `RequestException` is raised and logged using\n        the `error` level.\n\n    Example usage:\n\n    ```python\n    csvtask = {\n        'csv_import_task': {\n            '_ref': '12345678'\n        }\n    }\n    status = csvtask_status(csvtask)\n    ```\n    \"\"\"\n    _ref = csvtask[\"csv_import_task\"][\"_ref\"]\n    logging.debug(\"Checking status of csvimporttask %s\", _ref)\n    try:\n        res = self.get(_ref)\n        res.raise_for_status()\n    except requests.exceptions.RequestException as err:\n        logging.error(err)\n        raise WapiRequestException(err)\n    else:\n        logging.debug(res.json())\n\n    return res.json()\n</code></pre>"},{"location":"classes/nios/fileop/#ibx_sdk.nios.fileop.NiosFileopMixin.download_certificate","title":"<code>download_certificate(member, certificate_usage='ADMIN')</code>","text":"<p>Download SSL certificate from the Grid.</p> <p>Parameters:</p> Name Type Description Default <code>member</code> <code>str</code> <p>The identifier of the member for whom the certificate is being downloaded.</p> required <code>certificate_usage</code> <code>SupportedCertTypes</code> <p>The type of certificate to be downloaded (e.g., \"ADMIN\").</p> <code>'ADMIN'</code> Source code in <code>src/ibx_sdk/nios/fileop.py</code> <pre><code>def download_certificate(\n        self,\n        member: str,\n        certificate_usage: SupportedCertTypes = \"ADMIN\",\n):\n    \"\"\"\n    Download SSL certificate from the Grid.\n\n    Args:\n        member: The identifier of the member for whom the certificate is being downloaded.\n        certificate_usage: The type of certificate to be downloaded (e.g., \"ADMIN\").\n    \"\"\"\n    logging.info(\"Downloading %s certificate for %s\", certificate_usage, member)\n    payload = {\"member\": member, \"certificate_usage\": certificate_usage}\n    logging.debug(\"json payload %s\", payload)\n\n    try:\n        res = self.post(\"fileop\", params={\"_function\": \"downloadcertificate\"}, json=payload)\n        logging.debug(res.text)\n        res.raise_for_status()\n    except requests.exceptions.RequestException as err:\n        logging.error(err)\n        raise WapiRequestException(err)\n\n    obj = res.json()\n    download_url = obj.get(\"url\")\n    download_token = obj.get(\"token\")\n\n    self.file_download(token=download_token, url=download_url)\n</code></pre>"},{"location":"classes/nios/fileop/#ibx_sdk.nios.fileop.NiosFileopMixin.file_download","title":"<code>file_download(token, url, filename=None)</code>","text":"<p>file_download downloads the generated file from the NIOS Grid using a token and url</p> <p>Parameters:</p> Name Type Description Default <code>token</code> <code>str</code> <p>Authentication token required for the download completion.</p> required <code>url</code> <code>str</code> <p>URL of the file to be downloaded.</p> required <code>filename</code> <code>str</code> <p>Optional; name for the downloaded file. If not provided, it will be extracted from the URL.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/ibx_sdk/nios/fileop.py</code> <pre><code>def file_download(\n        self,\n        token: str,\n        url: str,\n        filename: str = None,\n) -&gt; None:\n    \"\"\"\n    file_download downloads the generated file from the NIOS Grid using a token and url\n\n    Args:\n        token: Authentication token required for the download completion.\n        url: URL of the file to be downloaded.\n        filename: Optional; name for the downloaded file. If not provided, it will be extracted from the URL.\n\n    Returns:\n        None\n    \"\"\"\n    logging.info(\"downloading data from %s\", url)\n    try:\n        res = self.__download_file(url, self.__get_cookies())\n    except requests.exceptions.RequestException as err:\n        logging.error(err)\n        raise WapiRequestException(err)\n\n    if not filename:\n        filename = util.extract_filename_from_url(url)\n\n    NiosFileopMixin.__write_file(filename=filename, data=res)\n\n    try:\n        self.__download_complete(token, filename, self.__get_cookies())\n    except requests.exceptions.RequestException as err:\n        logging.error(err)\n        raise WapiRequestException(err)\n</code></pre>"},{"location":"classes/nios/fileop/#ibx_sdk.nios.fileop.NiosFileopMixin.file_upload","title":"<code>file_upload(filename)</code>","text":"<p>Perform a file upload into the NIOS Grid.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path of the file to be uploaded.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The token received upon successful upload initialization.</p> <p>Raises:</p> Type Description <code>WapiRequestException</code> <p>If there is a request exception during the upload process.</p> Source code in <code>src/ibx_sdk/nios/fileop.py</code> <pre><code>def file_upload(self, filename: str) -&gt; str:\n    \"\"\"\n    Perform a file upload into the NIOS Grid.\n\n    Args:\n        filename: The path of the file to be uploaded.\n\n    Returns:\n        str: The token received upon successful upload initialization.\n\n    Raises:\n        WapiRequestException: If there is a request exception during the upload process.\n    \"\"\"\n    (_, filename) = os.path.split(filename)\n    filename = filename.replace(\"-\", \"_\")\n\n    # Call WAPI fileop Upload INIT\n    logging.info(\"step 1 - request uploadinit %s\", filename)\n    try:\n        obj = self.__upload_init(filename=filename)\n    except requests.exceptions.RequestException as err:\n        logging.error(err)\n        raise WapiRequestException(err)\n\n    upload_url = obj.get(\"url\")\n    token = obj.get(\"token\")\n\n    # specify a file handle for the file data to be uploaded\n    with open(filename, \"rb\") as csvfile:\n        # reset to top of the file\n        csvfile.seek(0)\n        upload_file = {\"file\": csvfile.read()}\n\n        # Upload the contents of the CSV file\n        logging.info(\"step 2 - post the files using the upload_url provided\")\n        try:\n            self.__upload_file(upload_url, upload_file, self.__get_cookies())\n        except requests.exceptions.RequestException as err:\n            logging.error(err)\n            raise WapiRequestException(err)\n        else:\n            return token\n</code></pre>"},{"location":"classes/nios/fileop/#ibx_sdk.nios.fileop.NiosFileopMixin.generate_csr","title":"<code>generate_csr(cn, member, algorithm='SHA-256', certificate_usage='ADMIN', comment=None, country=None, email=None, key_size=2048, locality=None, org=None, org_unit=None, state=None, subject_alternative_names=None)</code>","text":"<p>Generate a Certificate Signing Request</p> <p>Generate and download a CSR for a member of the grid. Once the CSR is generated it is downloaded and saved locally to the current working directory.</p> <p>Parameters:</p> Name Type Description Default <code>cn</code> <code>str</code> <p>Common Name for the certificate.</p> required <code>member</code> <code>str</code> <p>The member for which the certificate is being generated.</p> required <code>algorithm</code> <code>SupportedAlgorithms</code> <p>Algorithm used for certificate generation, default is \"SHA-256\".</p> <code>'SHA-256'</code> <code>certificate_usage</code> <code>SupportedCertUsages</code> <p>Purpose of the certificate, default is \"ADMIN\".</p> <code>'ADMIN'</code> <code>comment</code> <code>Optional[str]</code> <p>Optional comment for the certificate.</p> <code>None</code> <code>country</code> <code>Optional[str]</code> <p>Optional country code for the certificate.</p> <code>None</code> <code>email</code> <code>Optional[str]</code> <p>Optional email address for the certificate.</p> <code>None</code> <code>key_size</code> <code>Optional[SupportedKeySizes]</code> <p>Optional key size for the certificate, default is 2048.</p> <code>2048</code> <code>locality</code> <code>Optional[str]</code> <p>Optional locality or city for the certificate.</p> <code>None</code> <code>org</code> <code>Optional[str]</code> <p>Optional organization name for the certificate.</p> <code>None</code> <code>org_unit</code> <code>Optional[str]</code> <p>Optional organizational unit for the certificate.</p> <code>None</code> <code>state</code> <code>Optional[str]</code> <p>Optional state or province for the certificate.</p> <code>None</code> <code>subject_alternative_names</code> <code>Optional[list[dict]]</code> <p>Optional list of subject alternative names (SANs) for the certificate.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/ibx_sdk/nios/fileop.py</code> <pre><code>def generate_csr(\n        self,\n        cn: str,\n        member: str,\n        algorithm: SupportedAlgorithms = \"SHA-256\",\n        certificate_usage: SupportedCertUsages = \"ADMIN\",\n        comment: Optional[str] = None,\n        country: Optional[str] = None,\n        email: Optional[str] = None,\n        key_size: Optional[SupportedKeySizes] = 2048,\n        locality: Optional[str] = None,\n        org: Optional[str] = None,\n        org_unit: Optional[str] = None,\n        state: Optional[str] = None,\n        subject_alternative_names: Optional[list[dict]] = None\n) -&gt; None:\n    \"\"\"\n    Generate a Certificate Signing Request\n\n    Generate and download a CSR for a member of the grid. Once the CSR is generated it is downloaded and saved\n    locally to the current working directory.\n\n    Args:\n        cn: Common Name for the certificate.\n        member: The member for which the certificate is being generated.\n        algorithm: Algorithm used for certificate generation, default is \"SHA-256\".\n        certificate_usage: Purpose of the certificate, default is \"ADMIN\".\n        comment: Optional comment for the certificate.\n        country: Optional country code for the certificate.\n        email: Optional email address for the certificate.\n        key_size: Optional key size for the certificate, default is 2048.\n        locality: Optional locality or city for the certificate.\n        org: Optional organization name for the certificate.\n        org_unit: Optional organizational unit for the certificate.\n        state: Optional state or province for the certificate.\n        subject_alternative_names: Optional list of subject alternative names (SANs) for the certificate.\n\n    Returns:\n        None\n    \"\"\"\n    logging.info(\"generating %s csr for %s\", certificate_usage, member)\n    payload = {\n        \"cn\": cn,\n        \"member\": member,\n        \"algorithm\": algorithm,\n        \"certificate_usage\": certificate_usage,\n    }\n    if comment:\n        payload[\"comment\"] = comment\n    if country:\n        payload[\"country\"] = country\n    if email:\n        payload[\"email\"] = email\n    if key_size:\n        payload[\"key_size\"] = key_size\n    if locality:\n        payload[\"locality\"] = locality\n    if org:\n        payload[\"org\"] = org\n    if org_unit:\n        payload[\"org_unit\"] = org_unit\n    if state:\n        payload[\"state\"] = state\n    if subject_alternative_names:\n        payload[\"subject_alternative_names\"] = subject_alternative_names\n    logging.debug(\"json payload %s\", payload)\n\n    try:\n        res = self.post(\n            \"fileop\", params={\"_function\": \"generatecsr\"}, json=payload\n        )\n        logging.debug(res.text)\n        res.raise_for_status()\n    except requests.exceptions.RequestException as err:\n        logging.error(err)\n        raise WapiRequestException(err)\n\n    obj = res.json()\n    download_url = obj.get(\"url\")\n    download_token = obj.get(\"token\")\n\n    self.file_download(token=download_token, url=download_url)\n</code></pre>"},{"location":"classes/nios/fileop/#ibx_sdk.nios.fileop.NiosFileopMixin.generate_selfsigned_cert","title":"<code>generate_selfsigned_cert(cn, member, days_valid=365, algorithm='SHA-256', certificate_usage='ADMIN', comment=None, country=None, email=None, key_size=2048, locality=None, org=None, org_unit=None, state=None, subject_alternative_names=None)</code>","text":"<p>Generate a Self-Signed Certificate on the Grid.</p> <p>Parameters:</p> Name Type Description Default <code>cn</code> <code>str</code> <p>The common name for the certificate.</p> required <code>member</code> <code>str</code> <p>The member name for the certificate.</p> required <code>days_valid</code> <code>int</code> <p>The number of days the certificate is valid for. Default is 365.</p> <code>365</code> <code>algorithm</code> <code>SupportedAlgorithms</code> <p>The algorithm used for certificate generation. Default is \"SHA-256\".</p> <code>'SHA-256'</code> <code>certificate_usage</code> <code>SupportedCertUsages</code> <p>The usage type of the certificate. Default is \"ADMIN\".</p> <code>'ADMIN'</code> <code>comment</code> <code>Optional[str]</code> <p>Optional comment associated with the certificate.</p> <code>None</code> <code>country</code> <code>Optional[str]</code> <p>Optional country code.</p> <code>None</code> <code>email</code> <code>Optional[str]</code> <p>Optional email address.</p> <code>None</code> <code>key_size</code> <code>Optional[SupportedKeySizes]</code> <p>The size of the key used in certificate generation. Default is 2048.</p> <code>2048</code> <code>locality</code> <code>Optional[str]</code> <p>Optional locality (e.g., city).</p> <code>None</code> <code>org</code> <code>Optional[str]</code> <p>Optional organization name.</p> <code>None</code> <code>org_unit</code> <code>Optional[str]</code> <p>Optional organizational unit.</p> <code>None</code> <code>state</code> <code>Optional[str]</code> <p>Optional state or province.</p> <code>None</code> <code>subject_alternative_names</code> <code>Optional[list[dict]]</code> <p>Optional list of subject alternative names.</p> <code>None</code> Source code in <code>src/ibx_sdk/nios/fileop.py</code> <pre><code>def generate_selfsigned_cert(\n        self,\n        cn: str,\n        member: str,\n        days_valid: int = 365,\n        algorithm: SupportedAlgorithms = \"SHA-256\",\n        certificate_usage: SupportedCertUsages = \"ADMIN\",\n        comment: Optional[str] = None,\n        country: Optional[str] = None,\n        email: Optional[str] = None,\n        key_size: Optional[SupportedKeySizes] = 2048,\n        locality: Optional[str] = None,\n        org: Optional[str] = None,\n        org_unit: Optional[str] = None,\n        state: Optional[str] = None,\n        subject_alternative_names: Optional[list[dict]] = None\n):\n    \"\"\"\n    Generate a Self-Signed Certificate on the Grid.\n\n    Args:\n        cn: The common name for the certificate.\n        member: The member name for the certificate.\n        days_valid: The number of days the certificate is valid for. Default is 365.\n        algorithm: The algorithm used for certificate generation. Default is \"SHA-256\".\n        certificate_usage: The usage type of the certificate. Default is \"ADMIN\".\n        comment: Optional comment associated with the certificate.\n        country: Optional country code.\n        email: Optional email address.\n        key_size: The size of the key used in certificate generation. Default is 2048.\n        locality: Optional locality (e.g., city).\n        org: Optional organization name.\n        org_unit: Optional organizational unit.\n        state: Optional state or province.\n        subject_alternative_names: Optional list of subject alternative names.\n\n    \"\"\"\n    logging.info(\"generating self-signed certificate for %s\", member)\n    payload = {\n        \"cn\": cn,\n        \"member\": member,\n        \"algorithm\": algorithm,\n        \"certificate_usage\": certificate_usage,\n        \"days_valid\": days_valid,\n    }\n    if comment:\n        payload[\"comment\"] = comment\n    if country:\n        payload[\"country\"] = country\n    if email:\n        payload[\"email\"] = email\n    if key_size:\n        payload[\"key_size\"] = key_size\n    if locality:\n        payload[\"locality\"] = locality\n    if org:\n        payload[\"org\"] = org\n    if org_unit:\n        payload[\"org_unit\"] = org_unit\n    if state:\n        payload[\"state\"] = state\n    if subject_alternative_names:\n        payload[\"subject_alternative_names\"] = subject_alternative_names\n    logging.debug(\"json payload %s\", payload)\n\n    try:\n        res = self.post(\n            \"fileop\", params={\"_function\": \"generateselfsignedcert\"}, json=payload\n        )\n        logging.debug(res.text)\n        res.raise_for_status()\n    except requests.exceptions.RequestException as err:\n        logging.error(err)\n        raise WapiRequestException(err)\n\n    obj = res.json()\n    download_url = obj.get(\"url\")\n    download_token = obj.get(\"token\")\n\n    self.file_download(token=download_token, url=download_url)\n</code></pre>"},{"location":"classes/nios/fileop/#ibx_sdk.nios.fileop.NiosFileopMixin.get_csv_errors_file","title":"<code>get_csv_errors_file(filename, job_id)</code>","text":"<p>Fetches the csv-errors file for a specific job ID.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filename to be used when saving the csv-errors file.</p> required <code>job_id</code> <code>str</code> <p>The job ID for which the csv-errors file should be fetched.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>RequestException</code> <p>If there is an error during the request.</p> Source code in <code>src/ibx_sdk/nios/fileop.py</code> <pre><code>def get_csv_errors_file(self, filename: str, job_id: str) -&gt; None:\n    \"\"\"\n    Fetches the csv-errors file for a specific job ID.\n\n    Args:\n        filename (str): The filename to be used when saving the csv-errors file.\n        job_id (str): The job ID for which the csv-errors file should be fetched.\n\n    Returns:\n        None\n\n    Raises:\n        requests.exceptions.RequestException: If there is an error during the request.\n\n    \"\"\"\n    logging.debug(\"fetching csv-errors file for job id %s\", job_id)\n    payload = {\"import_id\": job_id}\n    try:\n        res = self.post(\n            \"fileop\", params={\"_function\": \"csv_error_log\"}, json=payload\n        )\n        logging.debug(pprint.pformat(res.text))\n        res.raise_for_status()\n    except requests.exceptions.RequestException as err:\n        logging.error(err)\n        raise WapiRequestException(err)\n\n    obj = res.json()\n    token = obj.get(\"token\")\n    download_url = obj.get(\"url\")\n\n    try:\n        res = self.__download_file(download_url, self.__get_cookies())\n        res.raise_for_status()\n    except requests.exceptions.RequestException as err:\n        logging.error(err)\n        raise WapiRequestException(err)\n\n    csv_error_file = f\"csv-errors-{filename}.csv\"\n    NiosFileopMixin.__write_file(filename=csv_error_file, data=res)\n\n    # We're done - so post to downloadcomplete function\n    try:\n        self.__download_complete(token, csv_error_file, self.__get_cookies())\n    except requests.exceptions.RequestException as err:\n        logging.error(err)\n        raise WapiRequestException(err)\n</code></pre>"},{"location":"classes/nios/fileop/#ibx_sdk.nios.fileop.NiosFileopMixin.get_lease_history","title":"<code>get_lease_history(member, start_time=None, end_time=None, remove_url=None)</code>","text":"<p>fetch DHCP lease history files from a NIOS Grid Member</p> <p>Parameters:</p> Name Type Description Default <code>member</code> <code>str</code> <p>A string representing the grid member that the DHCP lease history is being fetched from.</p> required <code>start_time</code> <code>int</code> <p>An optional integer representing the start time in epoch format. Defaults to None.</p> <code>None</code> <code>end_time</code> <code>int</code> <p>An optional integer representing the end time in epoch format. Defaults to None.</p> <code>None</code> <code>remove_url</code> <code>str</code> <p>An optional string representing the remove URL. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>A string representing the filename of the downloaded DHCP lease history file.</p> <p>Raises:</p> Type Description <code>WapiRequestException</code> <p>If there is an error in the API request.</p> Source code in <code>src/ibx_sdk/nios/fileop.py</code> <pre><code>def get_lease_history(\n        self,\n        member: str,\n        start_time: int = None,\n        end_time: int = None,\n        remove_url: str = None\n) -&gt; None:\n    \"\"\"\n    fetch DHCP lease history files from a NIOS Grid Member\n\n    Args:\n        member: A string representing the grid member that the DHCP lease history is being fetched from.\n        start_time: An optional integer representing the start time in epoch format. Defaults to None.\n        end_time: An optional integer representing the end time in epoch format. Defaults to None.\n        remove_url: An optional string representing the remove URL. Defaults to None.\n\n    Returns:\n        A string representing the filename of the downloaded DHCP lease history file.\n\n    Raises:\n        WapiRequestException: If there is an error in the API request.\n\n    \"\"\"\n    logging.info(\"fetching DHCP lease history from grid member %s\", member)\n    payload = {\"member\": member}\n    if start_time is not None:\n        payload[\"start_time\"] = start_time\n    if end_time is not None:\n        payload[\"end_time\"] = end_time\n    if remove_url is not None:\n        payload[\"remove_url\"] = remove_url\n    try:\n        res = self.post(\n            \"fileop\", params={\"_function\": \"getleasehistoryfiles\"}, json=payload\n        )\n        logging.debug(res.text)\n        res.raise_for_status()\n    except requests.exceptions.RequestException as err:\n        logging.error(err)\n        raise WapiRequestException(err)\n\n    obj = res.json()\n    download_url = obj.get(\"url\")\n    download_token = obj.get(\"token\")\n\n    self.file_download(token=download_token, url=download_url)\n</code></pre>"},{"location":"classes/nios/fileop/#ibx_sdk.nios.fileop.NiosFileopMixin.get_log_files","title":"<code>get_log_files(log_type, filename=None, endpoint=None, include_rotated=False, member=None, msserver=None, node_type=None)</code>","text":"<p>Fetch the log files for the provided member or msserver</p> <p>Parameters:</p> Name Type Description Default <code>log_type</code> <code>LogType</code> <p>The type of log files to fetch.</p> required <code>filename</code> <code>str</code> <p>The name of the log file to download (Default value = None)</p> <code>None</code> <code>endpoint</code> <code>str</code> <p>The specific endpoint for which to fetch log files. (Default: None)</p> <code>None</code> <code>include_rotated</code> <code>bool</code> <p>Whether to include rotated log files. (Default: False)</p> <code>False</code> <code>member</code> <code>str</code> <p>The member for which to fetch log files. (Default: None)</p> <code>None</code> <code>msserver</code> <code>str</code> <p>The msserver for which to fetch log files. (Default: None)</p> <code>None</code> <code>node_type</code> <code>Optional[Literal['ACTIVE', 'BACKUP']]</code> <p>The type of node for which to fetch log files. Can be 'ACTIVE' or        'BACKUP'. (Default: None)</p> <code>None</code> Source code in <code>src/ibx_sdk/nios/fileop.py</code> <pre><code>def get_log_files(\n        self,\n        log_type: LogType,\n        filename: Optional[str] = None,\n        endpoint: Optional[str] = None,\n        include_rotated: bool = False,\n        member: Optional[str] = None,\n        msserver: Optional[str] = None,\n        node_type: Optional[Literal[\"ACTIVE\", \"BACKUP\"]] = None,\n):\n    \"\"\"\n    Fetch the log files for the provided member or msserver\n\n    Args:\n        log_type (LogType): The type of log files to fetch.\n        filename (str): The name of the log file to download (Default value = None)\n        endpoint (str): The specific endpoint for which to fetch log files. (Default: None)\n        include_rotated (bool): Whether to include rotated log files. (Default: False)\n        member (str): The member for which to fetch log files. (Default: None)\n        msserver (str): The msserver for which to fetch log files. (Default: None)\n        node_type: The type of node for which to fetch log files. Can be 'ACTIVE' or\n                   'BACKUP'. (Default: None)\n    \"\"\"\n    logging.info(\"fetching %s log files for %s\", log_type, member)\n    payload = {\"log_type\": log_type, \"include_rotated\": include_rotated}\n\n    if endpoint:\n        payload[\"endpoint\"] = endpoint\n    if member:\n        payload[\"member\"] = member\n    if node_type:\n        payload[\"node_type\"] = node_type\n    if msserver:\n        payload[\"msserver\"] = msserver\n\n    logging.debug(\"json payload %s\", payload)\n\n    try:\n        res = self.post(\n            \"fileop\", params={\"_function\": \"get_log_files\"}, json=payload\n        )\n        logging.debug(res.text)\n        res.raise_for_status()\n    except requests.exceptions.RequestException as err:\n        logging.error(err)\n        raise WapiRequestException(err)\n\n    obj = res.json()\n    download_url = obj.get(\"url\")\n    download_token = obj.get(\"token\")\n\n    self.file_download(token=download_token, url=download_url, filename=filename)\n</code></pre>"},{"location":"classes/nios/fileop/#ibx_sdk.nios.fileop.NiosFileopMixin.get_support_bundle","title":"<code>get_support_bundle(member, filename=None, cached_zone_data=False, core_files=False, log_files=False, nm_snmp_logs=False, recursive_cache_file=False, remote_url=None, rotate_log_files=False)</code>","text":"<p>Get the support bundle for a member.</p> <p>Parameters:</p> Name Type Description Default <code>member</code> <code>str</code> <p>The member for which to retrieve the support bundle.</p> required <code>filename</code> <code>str</code> <p>The filename of the support bundle.</p> <code>None</code> <code>cached_zone_data</code> <code>bool</code> <p>Whether to include cached zone data in the support                                bundle. Defaults to False.</p> <code>False</code> <code>core_files</code> <code>bool</code> <p>Whether to include core files in the support bundle.                          Defaults to False.</p> <code>False</code> <code>log_files</code> <code>bool</code> <p>Whether to include log files in the support bundle.                         Defaults to False.</p> <code>False</code> <code>nm_snmp_logs</code> <code>bool</code> <p>Whether to include NM SNMP logs in the support bundle.                            Defaults to False.</p> <code>False</code> <code>recursive_cache_file</code> <code>bool</code> <p>Whether to include recursive cache file in the                                    support bundle. Defaults to False.</p> <code>False</code> <code>remote_url</code> <code>str</code> <p>The remote URL where the support bundle will be uploaded.                         Defaults to None.</p> <code>None</code> <code>rotate_log_files</code> <code>bool</code> <p>Whether to rotate log files before creating the                                support bundle. Defaults to False.</p> <code>False</code> <p>Raises:</p> Type Description <code>RequestException</code> <p>If an error occurs during the request.</p> Source code in <code>src/ibx_sdk/nios/fileop.py</code> <pre><code>def get_support_bundle(\n        self,\n        member: str,\n        filename: Optional[str] = None,\n        cached_zone_data: bool = False,\n        core_files: bool = False,\n        log_files: bool = False,\n        nm_snmp_logs: bool = False,\n        recursive_cache_file: bool = False,\n        remote_url: Optional[str] = None,\n        rotate_log_files: bool = False,\n):\n    \"\"\"\n    Get the support bundle for a member.\n\n    Args:\n        member (str): The member for which to retrieve the support bundle.\n        filename (str, optional): The filename of the support bundle.\n        cached_zone_data (bool, optional): Whether to include cached zone data in the support\n                                           bundle. Defaults to False.\n        core_files (bool, optional): Whether to include core files in the support bundle.\n                                     Defaults to False.\n        log_files (bool, optional): Whether to include log files in the support bundle.\n                                    Defaults to False.\n        nm_snmp_logs (bool, optional): Whether to include NM SNMP logs in the support bundle.\n                                       Defaults to False.\n        recursive_cache_file (bool, optional): Whether to include recursive cache file in the\n                                               support bundle. Defaults to False.\n        remote_url (str, optional): The remote URL where the support bundle will be uploaded.\n                                    Defaults to None.\n        rotate_log_files (bool, optional): Whether to rotate log files before creating the\n                                           support bundle. Defaults to False.\n\n    Raises:\n        requests.exceptions.RequestException: If an error occurs during the request.\n\n    \"\"\"\n    logging.info(\"performing get_support_bundle for %s object(s)\", member)\n    payload = {\n        \"member\": member,\n        \"cached_zone_data\": cached_zone_data,\n        \"core_files\": core_files,\n        \"log_files\": log_files,\n        \"nm_snmp_logs\": nm_snmp_logs,\n        \"recursive_cache_file\": recursive_cache_file,\n        \"rotate_log_files\": rotate_log_files,\n    }\n    if remote_url:\n        payload[\"remote_url\"] = remote_url\n    logging.debug(pprint.pformat(payload))\n    try:\n        res = self.post(\n            \"fileop\", params={\"_function\": \"get_support_bundle\"}, json=payload\n        )\n        logging.debug(res.text)\n        res.raise_for_status()\n    except requests.exceptions.RequestException as err:\n        logging.error(err)\n        raise WapiRequestException(err)\n\n    obj = res.json()\n    download_url = obj.get(\"url\")\n    download_token = obj.get(\"token\")\n\n    self.file_download(token=download_token, url=download_url, filename=filename)\n</code></pre>"},{"location":"classes/nios/fileop/#ibx_sdk.nios.fileop.NiosFileopMixin.grid_backup","title":"<code>grid_backup(filename=None)</code>","text":"<p>Perform a NIOS Grid Backup.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>Optional[str]</code> <p>str, optional. The name of the backup file. Default is 'database.tgz'.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>RequestException</code> <p>If an error occurs during the backup process.</p> Source code in <code>src/ibx_sdk/nios/fileop.py</code> <pre><code>def grid_backup(self, filename: Optional[str] = None) -&gt; None:\n    \"\"\"\n    Perform a NIOS Grid Backup.\n\n    Args:\n        filename: str, optional. The name of the backup file. Default is 'database.tgz'.\n\n    Returns:\n        None\n\n    Raises:\n        requests.exceptions.RequestException: If an error occurs during the backup process.\n    \"\"\"\n    payload = {\"type\": \"BACKUP\"}\n\n    logging.info(\"step 1 - request gridbackup %s\", filename)\n    try:\n        res = self.__getgriddata(payload, self.__get_cookies())\n    except requests.exceptions.RequestException as err:\n        logging.error(err)\n        raise WapiRequestException(err)\n\n    token = res.get(\"token\")\n    download_url = res.get(\"url\")\n\n    logging.info(\"step 2 - saving backup to %s\", filename)\n    self.file_download(token=token, url=download_url, filename=filename)\n</code></pre>"},{"location":"classes/nios/fileop/#ibx_sdk.nios.fileop.NiosFileopMixin.grid_restore","title":"<code>grid_restore(filename='database.tgz', mode='NORMAL', keep_grid_ip=False)</code>","text":"<p>Perform a NIOS Grid restore of a database using a given file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The filename of the database file to be restored. Default is             \"database.tgz\".</p> <code>'database.tgz'</code> <code>mode</code> <code>GridRestoreMode</code> <p>The restore mode to be used. Default is \"NORMAL\".</p> <code>'NORMAL'</code> <code>keep_grid_ip</code> <code>bool</code> <p>Indicates whether to keep the grid IP address. Default is False.</p> <code>False</code> Source code in <code>src/ibx_sdk/nios/fileop.py</code> <pre><code>def grid_restore(\n        self,\n        filename: str = \"database.tgz\",\n        mode: GridRestoreMode = \"NORMAL\",\n        keep_grid_ip: bool = False,\n):\n    \"\"\"\n    Perform a NIOS Grid restore of a database using a given file.\n\n    Args:\n        filename (str): The filename of the database file to be restored. Default is\n                        \"database.tgz\".\n        mode (GridRestoreMode): The restore mode to be used. Default is \"NORMAL\".\n        keep_grid_ip (bool): Indicates whether to keep the grid IP address. Default is False.\n\n    \"\"\"\n    token = self.file_upload(filename=filename)\n\n    # Execute the restore\n    logging.info(\"step 4 - execute the grid restore\")\n    try:\n        self.__restore_database(keep_grid_ip, mode, token, self.__get_cookies())\n    except requests.exceptions.RequestException as err:\n        logging.error(\"step 4 - Error: %s\", err)\n        raise WapiRequestException(err)\n    logging.info(\"Grid restore successful!\")\n</code></pre>"},{"location":"classes/nios/fileop/#ibx_sdk.nios.fileop.NiosFileopMixin.member_config","title":"<code>member_config(member, conf_type, filename=None, remote_url=None)</code>","text":"<p>Fetch member configuration file for given service type.</p> <p>Parameters:</p> Name Type Description Default <code>member</code> <code>str</code> <p>A string representing the grid member.</p> required <code>conf_type</code> <code>MemberDataType</code> <p>An enum representing the type of config file.</p> required <code>filename</code> <code>Optional[str]</code> <p>A string value of the filename to save</p> <code>None</code> <code>remote_url</code> <code>str</code> <p>An optional string representing the remote URL.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>A string representing the downloaded file.</p> Source code in <code>src/ibx_sdk/nios/fileop.py</code> <pre><code>def member_config(\n        self,\n        member: str,\n        conf_type: MemberDataType,\n        filename: Optional[str] = None,\n        remote_url: str = None,\n) -&gt; None:\n    \"\"\"\n    Fetch member configuration file for given service type.\n\n    Args:\n        member: A string representing the grid member.\n        conf_type: An enum representing the type of config file.\n        filename: A string value of the filename to save\n        remote_url: An optional string representing the remote URL.\n\n    Returns:\n        A string representing the downloaded file.\n\n    \"\"\"\n    conf_type = conf_type.upper()\n    logging.info(\"fetching %s config file for grid member %s\", conf_type, member)\n    payload = {\"member\": member, \"type\": conf_type}\n    if remote_url:\n        payload[\"remote_url\"] = remote_url\n    try:\n        res = self.post(\n            \"fileop\", params={\"_function\": \"getmemberdata\"}, json=payload\n        )\n        logging.debug(res.text)\n        res.raise_for_status()\n    except requests.exceptions.RequestException as err:\n        logging.error(err)\n        raise WapiRequestException(err)\n\n    obj = res.json()\n    download_url = obj.get(\"url\")\n    download_token = obj.get(\"token\")\n\n    self.file_download(token=download_token, url=download_url, filename=filename)\n</code></pre>"},{"location":"classes/nios/fileop/#ibx_sdk.nios.fileop.NiosFileopMixin.upload_certificate","title":"<code>upload_certificate(member, filename, certificate_usage='ADMIN')</code>","text":"<p>Upload an SSL Certificate file to the Grid</p> <p>Parameters:</p> Name Type Description Default <code>member</code> <code>str</code> <p>The member identifier to which the certificate will be uploaded.</p> required <code>filename</code> <code>str</code> <p>The filename of the certificate to be uploaded.</p> required <code>certificate_usage</code> <code>SupportedCertTypes</code> <p>The usage type of the certificate. Default is \"ADMIN\".</p> <code>'ADMIN'</code> <p>Raises:</p> Type Description <code>WapiRequestException</code> <p>If there is an error during the request to upload the certificate.</p> Source code in <code>src/ibx_sdk/nios/fileop.py</code> <pre><code>def upload_certificate(\n        self,\n        member: str,\n        filename: str,\n        certificate_usage: SupportedCertTypes = \"ADMIN\",\n):\n    \"\"\"\n    Upload an SSL Certificate file to the Grid\n\n    Args:\n        member: The member identifier to which the certificate will be uploaded.\n        filename: The filename of the certificate to be uploaded.\n        certificate_usage: The usage type of the certificate. Default is \"ADMIN\".\n\n    Raises:\n        WapiRequestException: If there is an error during the request to upload the certificate.\n    \"\"\"\n    token = self.file_upload(filename=filename)\n\n    # submit task to CSV Job Manager\n    logging.info(\"step 3 - upload %s certificate on %s\", certificate_usage, member)\n    payload = {\"certificate_usage\": certificate_usage, \"member\": member, \"token\": token}\n    try:\n        res = self.post(\n            \"fileop\",\n            params={\"_function\": \"uploadcertificate\"},\n            json=payload,\n            cookies=self.__get_cookies(),\n        )\n        logging.debug(pprint.pformat(res.text))\n        res.raise_for_status()\n    except requests.exceptions.RequestException as err:\n        logging.error(err)\n        raise WapiRequestException(err)\n</code></pre>"},{"location":"classes/nios/gift/","title":"NIOS WAPI Operations","text":"<p>Copyright 2023 Infoblox</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p> <pre><code>https://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>"},{"location":"classes/nios/gift/#ibx_sdk.nios.gift.Gift","title":"<code>Gift</code>","text":"<p>             Bases: <code>Session</code>, <code>NiosServiceMixin</code>, <code>NiosFileopMixin</code></p> <p>Handles interactions with the Infoblox WAPI.</p> <p>This class provides a range of classes to interact with Infoblox WAPI, including session management, data retrieval, file operations, and service management.</p> <p>Attributes:</p> Name Type Description <code>grid_mgr</code> <code>str</code> <p>IP address or hostname of the Grid Manager.</p> <code>wapi_ver</code> <code>str</code> <p>Version of the Infoblox WAPI.</p> <code>ssl_verify</code> <code>bool</code> <p>Flag to determine SSL certificate verification.</p> <code>conn</code> <code>Session</code> <p>Active session to the WAPI grid. Default is                                         None.</p> <code>grid_ref</code> <code>str</code> <p>Reference ID of the connected grid. Default is None.</p> <p>Examples:</p> <p>Initialize the WAPI instance with a dictionary of properties:</p> <pre><code>wapi_properties = {\n    'grid_mgr': 'gm.example.com',\n    'wapi_ver': '2.11',\n    'ssl_verify': False\n}\nwapi = Gift(wapi_properties)\n\nwapi.connect(username='admin', password='infoblox')\n</code></pre> <p>Build up the WAPI instance one property at a time:</p> <pre><code>wapi = Gift()\n\nwapi.grid_mgr = 'gm.example.com'\nwapi.wapi_ver = '2.11'\nwapi.ssl_verify = False\n\nwapi.connect(username='admin', password='infoblox')\n</code></pre> Source code in <code>src/ibx_sdk/nios/gift.py</code> <pre><code>class Gift(requests.sessions.Session, NiosServiceMixin, NiosFileopMixin):\n    \"\"\"Handles interactions with the Infoblox WAPI.\n\n    This class provides a range of classes to interact with Infoblox WAPI,\n    including session management, data retrieval, file operations, and service management.\n\n    Attributes:\n        grid_mgr (str): IP address or hostname of the Grid Manager.\n        wapi_ver (str): Version of the Infoblox WAPI.\n        ssl_verify (bool): Flag to determine SSL certificate verification.\n        conn (requests.sessions.Session, optional): Active session to the WAPI grid. Default is\n                                                    None.\n        grid_ref (str, optional): Reference ID of the connected grid. Default is None.\n\n    Examples:\n\n    Initialize the WAPI instance with a dictionary of properties:\n\n    ```py\n\n    wapi_properties = {\n        'grid_mgr': 'gm.example.com',\n        'wapi_ver': '2.11',\n        'ssl_verify': False\n    }\n    wapi = Gift(wapi_properties)\n\n    wapi.connect(username='admin', password='infoblox')\n\n    ```\n\n    Build up the WAPI instance one property at a time:\n\n    ```python\n\n    wapi = Gift()\n\n    wapi.grid_mgr = 'gm.example.com'\n    wapi.wapi_ver = '2.11'\n    wapi.ssl_verify = False\n\n    wapi.connect(username='admin', password='infoblox')\n\n    ```\n    \"\"\"\n\n    def __init__(\n        self,\n        grid_mgr: str = None,\n        wapi_ver: str = \"2.5\",\n        ssl_verify: Union[bool, str] = False,\n    ) -&gt; None:\n        super().__init__()\n        self.grid_mgr = grid_mgr\n        self.wapi_ver = wapi_ver\n        self.ssl_verify = ssl_verify\n        self.conn = None\n        self.grid_ref = None\n\n    def __repr__(self):\n        args = []\n        for key, value in self.__dict__.items():\n            args.append(f\"{key}={value}\")\n        return f\"{self.__class__.__qualname__}({', '.join(args)})\"\n\n    @property\n    def url(self) -&gt; str:\n        \"\"\"\n        Constructs a property using `grid_mgr` and `wapi_ver` attributes for the WAPI class.\n\n        Parameters:\n        - grid_mgr (str): The IP address or hostname of the grid manager.\n        - wapi_ver (str): The version of the WAPI.\n\n        Returns:\n        - url (str): The URL constructed using the grid manager and WAPI version.\n\n        Raises:\n        - None.\n\n        Example:\n\n        ```python\n\n        wapi = Gift()\n        wapi.grid_mgr = '10.0.0.1'\n        wapi.wapi_ver = '2.10'\n        url = wapi.url\n\n        print(url)\n\n        ```\n        The above code example will return output:\n\n        ```\n        'https://10.0.0.1/wapi/v2.10'\n        ```\n\n        \"\"\"\n        if self.grid_mgr and self.wapi_ver:\n            return f\"https://{self.grid_mgr}/wapi/v{self.wapi_ver}\"\n        return \"\"\n\n    def connect(\n        self, username: str = None, password: str = None, certificate: str = None\n    ) -&gt; None:\n        \"\"\"\n        Make a connection to the grid manager using the WAPI instance\n\n        Args:\n            username: A string representing the username for the connection. (default: None)\n            password: A string representing the password for the connection. (default: None)\n            certificate: A string representing the certificate for the connection. (default: None)\n\n        Raises:\n            WapiInvalidParameterException: If neither a username and password nor a certificate\n                                           is provided.\n\n        \"\"\"\n        if not self.url:\n            logging.error(\"invalid url %s - unable to connect!\", self.url)\n            raise WapiInvalidParameterException\n\n        if username and password:\n            self.__basic_auth_request(username, password)\n        elif certificate:\n            self.__certificate_auth_request(certificate)\n        else:\n            raise WapiInvalidParameterException\n\n    def __certificate_auth_request(self, certificate: str) -&gt; Union[dict, None]:\n        \"\"\"\n        This private method performs a certificate authentication request to the API. It uses the\n        provided certificate to establish a connection with the API server using the requests\n        library.\n\n        Args:\n            certificate (str): The certificate to be used for authentication with the API.\n\n        Returns:\n            grid _ref (dict): A dictionary\n\n        Raises:\n            WapiRequestException: If there is an error with the request to the API.\n\n        \"\"\"\n        with requests.sessions.Session() as conn:\n            try:\n                res = conn.get(\n                    f\"{self.url}/grid\", cert=certificate, verify=self.ssl_verify\n                )\n                res.raise_for_status()\n            except requests.exceptions.RequestException as err:\n                logging.error(err)\n                raise WapiRequestException(err) from err\n            else:\n                grid = res.json()\n                setattr(self, \"conn\", conn)\n                setattr(self, \"grid_ref\", grid[0].get(\"_ref\"))\n                return grid[0].get(\"_ref\", \"\")\n\n    def __basic_auth_request(self, username: str, password: str) -&gt; Union[dict, None]:\n        \"\"\"\n        This private method makes a request to the specified URL with basic authentication using\n        the provided username and password. It stores the session connection in the instance\n        attribute 'conn*' and the grid reference in the instance attribute 'grid_ref'.\n\n        Note:\n            This method requires the 'requests' library to be installed.\n\n        Args:\n            username (str): The username for basic authentication.\n            password (str): The password for basic authentication.\n\n        Returns:\n            grid _ref (dict): A dictionary\n\n        Raises:\n            WapiRequestException: If an error occurs during the request.\n        \"\"\"\n        with requests.sessions.Session() as conn:\n            try:\n                res = conn.get(\n                    f\"{self.url}/grid\",\n                    auth=(username, password),\n                    verify=self.ssl_verify,\n                )\n                res.raise_for_status()\n            except requests.exceptions.RequestException as err:\n                logging.error(err)\n                raise WapiRequestException(err) from err\n            else:\n                grid = res.json()\n                setattr(self, \"conn\", conn)\n                setattr(self, \"grid_ref\", grid[0].get(\"_ref\"))\n                return grid[0].get(\"_ref\", \"\")\n\n    def object_fields(self, wapi_object: str) -&gt; Union[str, None]:\n        \"\"\"\n        Retrieves the object fields for a specified WAPI object.\n\n        Args:\n            wapi_object (str): The name of the WAPI object for which to retrieve the fields.\n\n        Returns:\n            Union[str, None]: A string containing the fields separated by commas, or None if an\n            error occurred.\n\n        Raises:\n            WapiRequestException: If there was an error connecting to the WAPI service.\n\n        Example:\n\n        ```py\n        wapi = Gift()\n        fields = wapi.object_fields('record:host')\n        if fields is not None:\n            print(f\"Fields: {fields}\")\n        ```\n        \"\"\"\n        try:\n            logging.debug(\"trying %s/%s?_schema\", self.url, wapi_object)\n            res = self.conn.get(\n                f\"{self.url}/{wapi_object}?_schema\", verify=self.ssl_verify\n            )\n            res.raise_for_status()\n            data = res.json()\n        except requests.exceptions.RequestException as err:\n            logging.error(err)\n            raise WapiRequestException(err)\n        else:\n            fields = \",\".join(\n                field[\"name\"]\n                for field in data.get(\"fields\")\n                if \"r\" in field.get(\"supports\")\n            )\n        return fields\n\n    def max_wapi_ver(self) -&gt; None:\n        \"\"\"\n        Retrieves and sets the maximum supported version of the WAPI.\n\n        This method queries the WAPI to find the highest supported version and updates\n        the `wapi_ver` attribute of the instance with this value. It does not return\n        any value.\n\n        Raises:\n            WapiRequestException: If there is an error in making the GET request to retrieve\n                                  the WAPI version. This could be due to network issues,\n                                  authentication errors,\n                                  or other problems in the request process.\n\n        Example Usage:\n        ```python\n        session = Gift()\n        session.max_wapi_ver()\n        print(session.wapi_ver)  # Prints the maximum supported WAPI version\n        ```\n\n        Note:\n            This method updates the `wapi_ver` attribute of the WAPI session instance.\n        \"\"\"\n\n        url = f\"https://{self.grid_mgr}/wapi/v1.0/?_schema\"\n        try:\n            logging.debug(\"trying %s\", url)\n            res = self.conn.get(url, verify=False)\n            res.raise_for_status()\n            data = res.json()\n        except requests.exceptions.RequestException as err:\n            logging.error(err)\n            raise WapiRequestException(err)\n        else:\n            versions = data.get(\"supported_versions\")\n            versions.sort(key=lambda s: list(map(int, s.split(\".\"))))\n            logging.debug(versions)\n            max_wapi_ver = versions.pop()\n            setattr(self, \"wapi_ver\", max_wapi_ver)\n\n    def get(\n        self, wapi_object: str, params: Optional[dict] = None, **kwargs: Any\n    ) -&gt; Response:\n        \"\"\"\n        Return WAPI object(s).\n        Args:\n            wapi_object (str): The name of the WAPI object to retrieve.\n            params (Optional[dict]): Optional parameters to include in the request URL.\n            **kwargs: Additional keyword arguments to pass to the request.\n\n        Returns:\n            Response: The response object containing the result of the request.\n        \"\"\"\n        url = f\"{self.url}/{wapi_object}\"\n        try:\n            res = self.conn.request(\n                \"get\", url, params=params, verify=self.ssl_verify, **kwargs\n            )\n        except requests.exceptions.RequestException as err:\n            raise WapiRequestException(err)\n        else:\n            if res.status_code != 200:\n                raise WapiRequestException(res.text)\n        return res\n\n    def getone(\n        self, wapi_object: str, params: Optional[dict] = None, **kwargs: Any\n    ) -&gt; str:\n        \"\"\"\n        Return the reference of a single WAPI object.\n\n        Args:\n            wapi_object: A string representing the object to retrieve data from.\n            params: Optional dictionary of parameters to include in the request.\n            **kwargs: Additional keyword arguments to be passed to the request.\n\n        Returns:\n            str: A string response containing the _ref of the WAPI object.\n\n        Raises:\n            WapiRequestException: If multiple data records were returned or no data was returned.\n        \"\"\"\n        url = f\"{self.url}/{wapi_object}\"\n        try:\n            response = self.conn.request(\n                \"get\", url, params=params, verify=self.ssl_verify, **kwargs\n            )\n        except requests.exceptions.RequestException as err:\n            raise WapiRequestException(err)\n        else:\n            if response.status_code != 200:\n                raise WapiRequestException(response.text)\n            data = response.json()\n            if len(data) &gt; 1:\n                raise WapiRequestException(\"Multiple data records were returned\")\n            elif len(data) == 0:\n                raise WapiRequestException(\"No data was returned\")\n        return data[0].get(\"_ref\", \"\")\n\n    def post(\n        self,\n        wapi_object: str,\n        data: Optional[Union[dict, str]] = None,\n        json: Optional[dict] = None,\n        **kwargs: Any,\n    ) -&gt; Response:\n        \"\"\"\n        Create a POST request to create a WAPI object.\n\n        Args:\n            wapi_object: The object to which the POST request is being made.\n            data (optional): The data to be sent in the body of the request.\n                             Can be a dictionary or a string. Default is None.\n            json (optional): The JSON data to be sent in the body of the request.\n                             Should be a dictionary. Default is None.\n            **kwargs (optional): Additional keyword arguments to be passed to the request.\n\n        Returns:\n            Response: The response object containing the server's response to the POST request.\n        \"\"\"\n        url = f\"{self.url}/{wapi_object}\"\n        try:\n            res = self.conn.request(\n                \"post\", url, data=data, json=json, verify=self.ssl_verify, **kwargs\n            )\n        except requests.exceptions.RequestException as err:\n            raise WapiRequestException(err)\n        else:\n            if res.status_code not in [200, 201]:\n                raise WapiRequestException(res.text)\n            return res\n\n    def put(\n        self,\n        wapi_object_ref: str,\n        data: Optional[Union[dict, str]] = None,\n        **kwargs: Any,\n    ) -&gt; Response:\n        \"\"\"\n        Create a PUT request to update a WAPI object by its _ref.\n\n        Args:\n            wapi_object_ref: The reference string for the WAPI object.\n            data: Optional data to be sent with the request. Can be a dictionary or a string. Defaults to None.\n            **kwargs: Additional keyword arguments to be passed to the request.\n\n        Returns:\n            Response: The response object for the PUT request.\n        \"\"\"\n        url = f\"{self.url}/{wapi_object_ref}\"\n        try:\n            res = self.conn.request(\n                \"put\", url, data=data, verify=self.ssl_verify, **kwargs\n            )\n        except requests.exceptions.RequestException as err:\n            raise WapiRequestException(err)\n        else:\n            if res.status_code != 200:\n                raise WapiRequestException(res.text)\n            return res\n\n    def delete(self, wapi_object_ref: str, **kwargs: Any) -&gt; Response:\n        \"\"\"\n        Args:\n            wapi_object_ref (str): A string representing the reference to the WAPI object that\n                                   needs to be deleted.\n            **kwargs (Any): Additional keyword arguments that can be passed to the `request` method\n                            of the connection object.\n\n        Returns:\n            A `Response` object representing the response received from the server.\n\n        \"\"\"\n        url = f\"{self.url}/{wapi_object_ref}\"\n        try:\n            res = self.conn.request(\"delete\", url, verify=self.ssl_verify, **kwargs)\n        except requests.exceptions.RequestException as err:\n            raise WapiRequestException(err)\n        else:\n            if res.status_code != 200:\n                raise WapiRequestException(res.text)\n            return res\n</code></pre>"},{"location":"classes/nios/gift/#ibx_sdk.nios.gift.Gift.url","title":"<code>url: str</code>  <code>property</code>","text":"<p>Constructs a property using <code>grid_mgr</code> and <code>wapi_ver</code> attributes for the WAPI class.</p> <p>Parameters: - grid_mgr (str): The IP address or hostname of the grid manager. - wapi_ver (str): The version of the WAPI.</p> <p>Returns: - url (str): The URL constructed using the grid manager and WAPI version.</p> <p>Raises: - None.</p> <p>Example:</p> <p><pre><code>wapi = Gift()\nwapi.grid_mgr = '10.0.0.1'\nwapi.wapi_ver = '2.10'\nurl = wapi.url\n\nprint(url)\n</code></pre> The above code example will return output:</p> <pre><code>'https://10.0.0.1/wapi/v2.10'\n</code></pre>"},{"location":"classes/nios/gift/#ibx_sdk.nios.gift.Gift.__basic_auth_request","title":"<code>__basic_auth_request(username, password)</code>","text":"<p>This private method makes a request to the specified URL with basic authentication using the provided username and password. It stores the session connection in the instance attribute 'conn*' and the grid reference in the instance attribute 'grid_ref'.</p> Note <p>This method requires the 'requests' library to be installed.</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>The username for basic authentication.</p> required <code>password</code> <code>str</code> <p>The password for basic authentication.</p> required <p>Returns:</p> Type Description <code>Union[dict, None]</code> <p>grid _ref (dict): A dictionary</p> <p>Raises:</p> Type Description <code>WapiRequestException</code> <p>If an error occurs during the request.</p> Source code in <code>src/ibx_sdk/nios/gift.py</code> <pre><code>def __basic_auth_request(self, username: str, password: str) -&gt; Union[dict, None]:\n    \"\"\"\n    This private method makes a request to the specified URL with basic authentication using\n    the provided username and password. It stores the session connection in the instance\n    attribute 'conn*' and the grid reference in the instance attribute 'grid_ref'.\n\n    Note:\n        This method requires the 'requests' library to be installed.\n\n    Args:\n        username (str): The username for basic authentication.\n        password (str): The password for basic authentication.\n\n    Returns:\n        grid _ref (dict): A dictionary\n\n    Raises:\n        WapiRequestException: If an error occurs during the request.\n    \"\"\"\n    with requests.sessions.Session() as conn:\n        try:\n            res = conn.get(\n                f\"{self.url}/grid\",\n                auth=(username, password),\n                verify=self.ssl_verify,\n            )\n            res.raise_for_status()\n        except requests.exceptions.RequestException as err:\n            logging.error(err)\n            raise WapiRequestException(err) from err\n        else:\n            grid = res.json()\n            setattr(self, \"conn\", conn)\n            setattr(self, \"grid_ref\", grid[0].get(\"_ref\"))\n            return grid[0].get(\"_ref\", \"\")\n</code></pre>"},{"location":"classes/nios/gift/#ibx_sdk.nios.gift.Gift.__certificate_auth_request","title":"<code>__certificate_auth_request(certificate)</code>","text":"<p>This private method performs a certificate authentication request to the API. It uses the provided certificate to establish a connection with the API server using the requests library.</p> <p>Parameters:</p> Name Type Description Default <code>certificate</code> <code>str</code> <p>The certificate to be used for authentication with the API.</p> required <p>Returns:</p> Type Description <code>Union[dict, None]</code> <p>grid _ref (dict): A dictionary</p> <p>Raises:</p> Type Description <code>WapiRequestException</code> <p>If there is an error with the request to the API.</p> Source code in <code>src/ibx_sdk/nios/gift.py</code> <pre><code>def __certificate_auth_request(self, certificate: str) -&gt; Union[dict, None]:\n    \"\"\"\n    This private method performs a certificate authentication request to the API. It uses the\n    provided certificate to establish a connection with the API server using the requests\n    library.\n\n    Args:\n        certificate (str): The certificate to be used for authentication with the API.\n\n    Returns:\n        grid _ref (dict): A dictionary\n\n    Raises:\n        WapiRequestException: If there is an error with the request to the API.\n\n    \"\"\"\n    with requests.sessions.Session() as conn:\n        try:\n            res = conn.get(\n                f\"{self.url}/grid\", cert=certificate, verify=self.ssl_verify\n            )\n            res.raise_for_status()\n        except requests.exceptions.RequestException as err:\n            logging.error(err)\n            raise WapiRequestException(err) from err\n        else:\n            grid = res.json()\n            setattr(self, \"conn\", conn)\n            setattr(self, \"grid_ref\", grid[0].get(\"_ref\"))\n            return grid[0].get(\"_ref\", \"\")\n</code></pre>"},{"location":"classes/nios/gift/#ibx_sdk.nios.gift.Gift.connect","title":"<code>connect(username=None, password=None, certificate=None)</code>","text":"<p>Make a connection to the grid manager using the WAPI instance</p> <p>Parameters:</p> Name Type Description Default <code>username</code> <code>str</code> <p>A string representing the username for the connection. (default: None)</p> <code>None</code> <code>password</code> <code>str</code> <p>A string representing the password for the connection. (default: None)</p> <code>None</code> <code>certificate</code> <code>str</code> <p>A string representing the certificate for the connection. (default: None)</p> <code>None</code> <p>Raises:</p> Type Description <code>WapiInvalidParameterException</code> <p>If neither a username and password nor a certificate                            is provided.</p> Source code in <code>src/ibx_sdk/nios/gift.py</code> <pre><code>def connect(\n    self, username: str = None, password: str = None, certificate: str = None\n) -&gt; None:\n    \"\"\"\n    Make a connection to the grid manager using the WAPI instance\n\n    Args:\n        username: A string representing the username for the connection. (default: None)\n        password: A string representing the password for the connection. (default: None)\n        certificate: A string representing the certificate for the connection. (default: None)\n\n    Raises:\n        WapiInvalidParameterException: If neither a username and password nor a certificate\n                                       is provided.\n\n    \"\"\"\n    if not self.url:\n        logging.error(\"invalid url %s - unable to connect!\", self.url)\n        raise WapiInvalidParameterException\n\n    if username and password:\n        self.__basic_auth_request(username, password)\n    elif certificate:\n        self.__certificate_auth_request(certificate)\n    else:\n        raise WapiInvalidParameterException\n</code></pre>"},{"location":"classes/nios/gift/#ibx_sdk.nios.gift.Gift.delete","title":"<code>delete(wapi_object_ref, **kwargs)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>wapi_object_ref</code> <code>str</code> <p>A string representing the reference to the WAPI object that                    needs to be deleted.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments that can be passed to the <code>request</code> method             of the connection object.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Response</code> <p>A <code>Response</code> object representing the response received from the server.</p> Source code in <code>src/ibx_sdk/nios/gift.py</code> <pre><code>def delete(self, wapi_object_ref: str, **kwargs: Any) -&gt; Response:\n    \"\"\"\n    Args:\n        wapi_object_ref (str): A string representing the reference to the WAPI object that\n                               needs to be deleted.\n        **kwargs (Any): Additional keyword arguments that can be passed to the `request` method\n                        of the connection object.\n\n    Returns:\n        A `Response` object representing the response received from the server.\n\n    \"\"\"\n    url = f\"{self.url}/{wapi_object_ref}\"\n    try:\n        res = self.conn.request(\"delete\", url, verify=self.ssl_verify, **kwargs)\n    except requests.exceptions.RequestException as err:\n        raise WapiRequestException(err)\n    else:\n        if res.status_code != 200:\n            raise WapiRequestException(res.text)\n        return res\n</code></pre>"},{"location":"classes/nios/gift/#ibx_sdk.nios.gift.Gift.get","title":"<code>get(wapi_object, params=None, **kwargs)</code>","text":"<p>Return WAPI object(s). Args:     wapi_object (str): The name of the WAPI object to retrieve.     params (Optional[dict]): Optional parameters to include in the request URL.     **kwargs: Additional keyword arguments to pass to the request.</p> <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>The response object containing the result of the request.</p> Source code in <code>src/ibx_sdk/nios/gift.py</code> <pre><code>def get(\n    self, wapi_object: str, params: Optional[dict] = None, **kwargs: Any\n) -&gt; Response:\n    \"\"\"\n    Return WAPI object(s).\n    Args:\n        wapi_object (str): The name of the WAPI object to retrieve.\n        params (Optional[dict]): Optional parameters to include in the request URL.\n        **kwargs: Additional keyword arguments to pass to the request.\n\n    Returns:\n        Response: The response object containing the result of the request.\n    \"\"\"\n    url = f\"{self.url}/{wapi_object}\"\n    try:\n        res = self.conn.request(\n            \"get\", url, params=params, verify=self.ssl_verify, **kwargs\n        )\n    except requests.exceptions.RequestException as err:\n        raise WapiRequestException(err)\n    else:\n        if res.status_code != 200:\n            raise WapiRequestException(res.text)\n    return res\n</code></pre>"},{"location":"classes/nios/gift/#ibx_sdk.nios.gift.Gift.getone","title":"<code>getone(wapi_object, params=None, **kwargs)</code>","text":"<p>Return the reference of a single WAPI object.</p> <p>Parameters:</p> Name Type Description Default <code>wapi_object</code> <code>str</code> <p>A string representing the object to retrieve data from.</p> required <code>params</code> <code>Optional[dict]</code> <p>Optional dictionary of parameters to include in the request.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments to be passed to the request.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string response containing the _ref of the WAPI object.</p> <p>Raises:</p> Type Description <code>WapiRequestException</code> <p>If multiple data records were returned or no data was returned.</p> Source code in <code>src/ibx_sdk/nios/gift.py</code> <pre><code>def getone(\n    self, wapi_object: str, params: Optional[dict] = None, **kwargs: Any\n) -&gt; str:\n    \"\"\"\n    Return the reference of a single WAPI object.\n\n    Args:\n        wapi_object: A string representing the object to retrieve data from.\n        params: Optional dictionary of parameters to include in the request.\n        **kwargs: Additional keyword arguments to be passed to the request.\n\n    Returns:\n        str: A string response containing the _ref of the WAPI object.\n\n    Raises:\n        WapiRequestException: If multiple data records were returned or no data was returned.\n    \"\"\"\n    url = f\"{self.url}/{wapi_object}\"\n    try:\n        response = self.conn.request(\n            \"get\", url, params=params, verify=self.ssl_verify, **kwargs\n        )\n    except requests.exceptions.RequestException as err:\n        raise WapiRequestException(err)\n    else:\n        if response.status_code != 200:\n            raise WapiRequestException(response.text)\n        data = response.json()\n        if len(data) &gt; 1:\n            raise WapiRequestException(\"Multiple data records were returned\")\n        elif len(data) == 0:\n            raise WapiRequestException(\"No data was returned\")\n    return data[0].get(\"_ref\", \"\")\n</code></pre>"},{"location":"classes/nios/gift/#ibx_sdk.nios.gift.Gift.max_wapi_ver","title":"<code>max_wapi_ver()</code>","text":"<p>Retrieves and sets the maximum supported version of the WAPI.</p> <p>This method queries the WAPI to find the highest supported version and updates the <code>wapi_ver</code> attribute of the instance with this value. It does not return any value.</p> <p>Raises:</p> Type Description <code>WapiRequestException</code> <p>If there is an error in making the GET request to retrieve                   the WAPI version. This could be due to network issues,                   authentication errors,                   or other problems in the request process.</p> <p>Example Usage: <pre><code>session = Gift()\nsession.max_wapi_ver()\nprint(session.wapi_ver)  # Prints the maximum supported WAPI version\n</code></pre></p> Note <p>This method updates the <code>wapi_ver</code> attribute of the WAPI session instance.</p> Source code in <code>src/ibx_sdk/nios/gift.py</code> <pre><code>def max_wapi_ver(self) -&gt; None:\n    \"\"\"\n    Retrieves and sets the maximum supported version of the WAPI.\n\n    This method queries the WAPI to find the highest supported version and updates\n    the `wapi_ver` attribute of the instance with this value. It does not return\n    any value.\n\n    Raises:\n        WapiRequestException: If there is an error in making the GET request to retrieve\n                              the WAPI version. This could be due to network issues,\n                              authentication errors,\n                              or other problems in the request process.\n\n    Example Usage:\n    ```python\n    session = Gift()\n    session.max_wapi_ver()\n    print(session.wapi_ver)  # Prints the maximum supported WAPI version\n    ```\n\n    Note:\n        This method updates the `wapi_ver` attribute of the WAPI session instance.\n    \"\"\"\n\n    url = f\"https://{self.grid_mgr}/wapi/v1.0/?_schema\"\n    try:\n        logging.debug(\"trying %s\", url)\n        res = self.conn.get(url, verify=False)\n        res.raise_for_status()\n        data = res.json()\n    except requests.exceptions.RequestException as err:\n        logging.error(err)\n        raise WapiRequestException(err)\n    else:\n        versions = data.get(\"supported_versions\")\n        versions.sort(key=lambda s: list(map(int, s.split(\".\"))))\n        logging.debug(versions)\n        max_wapi_ver = versions.pop()\n        setattr(self, \"wapi_ver\", max_wapi_ver)\n</code></pre>"},{"location":"classes/nios/gift/#ibx_sdk.nios.gift.Gift.object_fields","title":"<code>object_fields(wapi_object)</code>","text":"<p>Retrieves the object fields for a specified WAPI object.</p> <p>Parameters:</p> Name Type Description Default <code>wapi_object</code> <code>str</code> <p>The name of the WAPI object for which to retrieve the fields.</p> required <p>Returns:</p> Type Description <code>Union[str, None]</code> <p>Union[str, None]: A string containing the fields separated by commas, or None if an</p> <code>Union[str, None]</code> <p>error occurred.</p> <p>Raises:</p> Type Description <code>WapiRequestException</code> <p>If there was an error connecting to the WAPI service.</p> <p>Example:</p> <pre><code>wapi = Gift()\nfields = wapi.object_fields('record:host')\nif fields is not None:\n    print(f\"Fields: {fields}\")\n</code></pre> Source code in <code>src/ibx_sdk/nios/gift.py</code> <pre><code>def object_fields(self, wapi_object: str) -&gt; Union[str, None]:\n    \"\"\"\n    Retrieves the object fields for a specified WAPI object.\n\n    Args:\n        wapi_object (str): The name of the WAPI object for which to retrieve the fields.\n\n    Returns:\n        Union[str, None]: A string containing the fields separated by commas, or None if an\n        error occurred.\n\n    Raises:\n        WapiRequestException: If there was an error connecting to the WAPI service.\n\n    Example:\n\n    ```py\n    wapi = Gift()\n    fields = wapi.object_fields('record:host')\n    if fields is not None:\n        print(f\"Fields: {fields}\")\n    ```\n    \"\"\"\n    try:\n        logging.debug(\"trying %s/%s?_schema\", self.url, wapi_object)\n        res = self.conn.get(\n            f\"{self.url}/{wapi_object}?_schema\", verify=self.ssl_verify\n        )\n        res.raise_for_status()\n        data = res.json()\n    except requests.exceptions.RequestException as err:\n        logging.error(err)\n        raise WapiRequestException(err)\n    else:\n        fields = \",\".join(\n            field[\"name\"]\n            for field in data.get(\"fields\")\n            if \"r\" in field.get(\"supports\")\n        )\n    return fields\n</code></pre>"},{"location":"classes/nios/gift/#ibx_sdk.nios.gift.Gift.post","title":"<code>post(wapi_object, data=None, json=None, **kwargs)</code>","text":"<p>Create a POST request to create a WAPI object.</p> <p>Parameters:</p> Name Type Description Default <code>wapi_object</code> <code>str</code> <p>The object to which the POST request is being made.</p> required <code>data</code> <code>optional</code> <p>The data to be sent in the body of the request.              Can be a dictionary or a string. Default is None.</p> <code>None</code> <code>json</code> <code>optional</code> <p>The JSON data to be sent in the body of the request.              Should be a dictionary. Default is None.</p> <code>None</code> <code>**kwargs</code> <code>optional</code> <p>Additional keyword arguments to be passed to the request.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>The response object containing the server's response to the POST request.</p> Source code in <code>src/ibx_sdk/nios/gift.py</code> <pre><code>def post(\n    self,\n    wapi_object: str,\n    data: Optional[Union[dict, str]] = None,\n    json: Optional[dict] = None,\n    **kwargs: Any,\n) -&gt; Response:\n    \"\"\"\n    Create a POST request to create a WAPI object.\n\n    Args:\n        wapi_object: The object to which the POST request is being made.\n        data (optional): The data to be sent in the body of the request.\n                         Can be a dictionary or a string. Default is None.\n        json (optional): The JSON data to be sent in the body of the request.\n                         Should be a dictionary. Default is None.\n        **kwargs (optional): Additional keyword arguments to be passed to the request.\n\n    Returns:\n        Response: The response object containing the server's response to the POST request.\n    \"\"\"\n    url = f\"{self.url}/{wapi_object}\"\n    try:\n        res = self.conn.request(\n            \"post\", url, data=data, json=json, verify=self.ssl_verify, **kwargs\n        )\n    except requests.exceptions.RequestException as err:\n        raise WapiRequestException(err)\n    else:\n        if res.status_code not in [200, 201]:\n            raise WapiRequestException(res.text)\n        return res\n</code></pre>"},{"location":"classes/nios/gift/#ibx_sdk.nios.gift.Gift.put","title":"<code>put(wapi_object_ref, data=None, **kwargs)</code>","text":"<p>Create a PUT request to update a WAPI object by its _ref.</p> <p>Parameters:</p> Name Type Description Default <code>wapi_object_ref</code> <code>str</code> <p>The reference string for the WAPI object.</p> required <code>data</code> <code>Optional[Union[dict, str]]</code> <p>Optional data to be sent with the request. Can be a dictionary or a string. Defaults to None.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional keyword arguments to be passed to the request.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Response</code> <code>Response</code> <p>The response object for the PUT request.</p> Source code in <code>src/ibx_sdk/nios/gift.py</code> <pre><code>def put(\n    self,\n    wapi_object_ref: str,\n    data: Optional[Union[dict, str]] = None,\n    **kwargs: Any,\n) -&gt; Response:\n    \"\"\"\n    Create a PUT request to update a WAPI object by its _ref.\n\n    Args:\n        wapi_object_ref: The reference string for the WAPI object.\n        data: Optional data to be sent with the request. Can be a dictionary or a string. Defaults to None.\n        **kwargs: Additional keyword arguments to be passed to the request.\n\n    Returns:\n        Response: The response object for the PUT request.\n    \"\"\"\n    url = f\"{self.url}/{wapi_object_ref}\"\n    try:\n        res = self.conn.request(\n            \"put\", url, data=data, verify=self.ssl_verify, **kwargs\n        )\n    except requests.exceptions.RequestException as err:\n        raise WapiRequestException(err)\n    else:\n        if res.status_code != 200:\n            raise WapiRequestException(res.text)\n        return res\n</code></pre>"},{"location":"classes/nios/service/","title":"Services","text":"<p>Copyright 2023 Infoblox</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p> <pre><code>https://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>"},{"location":"classes/nios/service/#ibx_sdk.nios.service.NiosServiceMixin","title":"<code>NiosServiceMixin</code>","text":"<p>NIOS Service Mixin class</p> Source code in <code>src/ibx_sdk/nios/service.py</code> <pre><code>class NiosServiceMixin:\n    \"\"\"\n    NIOS Service Mixin class\n    \"\"\"\n\n    RestartMode = Literal[\"GROUPED\", \"SEQUENTIAL\", \"SIMULTANEOUS\"]\n    RestartOption = Literal[\"FORCE_RESTART\", \"RESTART_IF_NEEDED\"]\n    RestartServices = Literal[\"ALL\", \"DNS\", \"DHCP\", \"DHCPV4\", \"DHCPV6\"]\n\n    def service_restart(\n        self,\n        groups: Optional[list] = None,\n        members: Optional[list[str]] = None,\n        mode: Optional[RestartMode] = None,\n        restart_option: Optional[RestartOption] = \"RESTART_IF_NEEDED\",\n        services: Optional[list[RestartServices]] = None,\n        user_name: Optional[str] = None,\n    ) -&gt; None:\n        \"\"\"\n        Restarts specified services on the grid.\n\n        Args:\n            self (Gift): Gift object\n            groups (Optional[list]): List of group names. Default is None.\n            members (Optional[list[str]]): List of member names. Default is None.\n            mode (Optional[ServiceRestartMode]): Restart mode. Default is None.\n            restart_option (Optional[ServiceRestartOption]): Restart option. Default is\n                            'RESTART_IF_NEEDED'.\n            services (Optional[list[ServiceRestartServices]]): List of services to restart.\n                                                               Default is None.\n            user_name (Optional[str]): Username. Default is None.\n\n        Returns:\n            None\n\n        Raises:\n            requests.exceptions.RequestException: If there is an error sending the restart request.\n\n        Examples:\n            # Restart services in a group\n            service_restart(groups=['group_name'])\n\n            # Restart services of specific members\n            service_restart(members=['member1', 'member2'])\n\n            # Restart services with a specific restart mode\n            service_restart(mode=ServiceRestartMode.IMMEDIATE)\n\n            # Restart services with a specific restart option\n            service_restart(restart_option=ServiceRestartOption.RESTART_IF_NEEDED)\n\n            # Restart specific services\n            service_restart(services=[ServiceRestartServices.SERVICE_NAME1,\n            ServiceRestartServices.SERVICE_NAME2])\n\n            # Restart services for a specific user\n            service_restart(user_name='username')\n        \"\"\"\n        data = {}\n        if groups:\n            data[\"groups\"] = [groups]\n        if members:\n            data[\"members\"] = [members]\n        if mode:\n            data[\"mode\"] = mode\n        if restart_option:\n            data[\"restart_option\"] = restart_option\n        if services:\n            data[\"services\"] = [services]\n        if user_name:\n            data[\"user_name\"] = user_name\n\n        logging.debug(pprint.pformat(data))\n\n        try:\n            res = self.post(\n                self.grid_ref, params={\"_function\": \"restartservices\"}, json=data\n            )\n            logging.debug(res.text)\n            res.raise_for_status()\n        except requests.exceptions.RequestException as err:\n            logging.error(err)\n            raise WapiRequestException(err)\n        else:\n            logging.info(\"successfully restarted %s services\", data.get(\"services\"))\n\n    def update_service_status(self, services: str = \"ALL\") -&gt; None:\n        \"\"\"\n        Updates the status of a service.\n\n        Args:\n            self (Gift): The instance of the class.\n            services (str): The service option to update the status for. Default value is 'ALL'.\n\n        Returns:\n            None\n\n        Raises:\n            requests.exceptions.RequestException: If an error occurs while making the request.\n        \"\"\"\n        payload = {\"service_option\": services}\n        try:\n            res = self.post(\n                self.grid_ref,\n                params={\"_function\": \"requestrestartservicestatus\"},\n                json=payload,\n            )\n            logging.debug(res.text)\n            res.raise_for_status()\n        except requests.exceptions.RequestException as err:\n            logging.error(err)\n            raise WapiRequestException(err)\n\n    def get_service_restart_status(self) -&gt; dict:\n        \"\"\"\n        Retrieves the status of a service restart.\n\n        Args:\n            self (Gift): The instance of the Gift class\n\n        Returns:\n            dict: A dictionary containing the service restart status information.\n\n        Raises:\n            requests.exceptions.SSLError: If there is an SSL certificate error.\n            requests.exceptions.HTTPError: If there is an HTTP error.\n            requests.exceptions.RequestException: If there is a general request error.\n        \"\"\"\n        try:\n            response = self.get(\"restartservicestatus\")\n            logging.debug(response.text)\n            response.raise_for_status()\n        except requests.exceptions.SSLError as err:\n            logging.error(err)\n            raise WapiRequestException(err)\n        except requests.exceptions.HTTPError as err:\n            logging.error(err)\n            raise WapiRequestException(err)\n        except requests.exceptions.RequestException as err:\n            logging.error(err)\n            raise WapiRequestException(err)\n        else:\n            return response.json()\n</code></pre>"},{"location":"classes/nios/service/#ibx_sdk.nios.service.NiosServiceMixin.get_service_restart_status","title":"<code>get_service_restart_status()</code>","text":"<p>Retrieves the status of a service restart.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <code>Gift</code> <p>The instance of the Gift class</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary containing the service restart status information.</p> <p>Raises:</p> Type Description <code>SSLError</code> <p>If there is an SSL certificate error.</p> <code>HTTPError</code> <p>If there is an HTTP error.</p> <code>RequestException</code> <p>If there is a general request error.</p> Source code in <code>src/ibx_sdk/nios/service.py</code> <pre><code>def get_service_restart_status(self) -&gt; dict:\n    \"\"\"\n    Retrieves the status of a service restart.\n\n    Args:\n        self (Gift): The instance of the Gift class\n\n    Returns:\n        dict: A dictionary containing the service restart status information.\n\n    Raises:\n        requests.exceptions.SSLError: If there is an SSL certificate error.\n        requests.exceptions.HTTPError: If there is an HTTP error.\n        requests.exceptions.RequestException: If there is a general request error.\n    \"\"\"\n    try:\n        response = self.get(\"restartservicestatus\")\n        logging.debug(response.text)\n        response.raise_for_status()\n    except requests.exceptions.SSLError as err:\n        logging.error(err)\n        raise WapiRequestException(err)\n    except requests.exceptions.HTTPError as err:\n        logging.error(err)\n        raise WapiRequestException(err)\n    except requests.exceptions.RequestException as err:\n        logging.error(err)\n        raise WapiRequestException(err)\n    else:\n        return response.json()\n</code></pre>"},{"location":"classes/nios/service/#ibx_sdk.nios.service.NiosServiceMixin.service_restart","title":"<code>service_restart(groups=None, members=None, mode=None, restart_option='RESTART_IF_NEEDED', services=None, user_name=None)</code>","text":"<p>Restarts specified services on the grid.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <code>Gift</code> <p>Gift object</p> required <code>groups</code> <code>Optional[list]</code> <p>List of group names. Default is None.</p> <code>None</code> <code>members</code> <code>Optional[list[str]]</code> <p>List of member names. Default is None.</p> <code>None</code> <code>mode</code> <code>Optional[ServiceRestartMode]</code> <p>Restart mode. Default is None.</p> <code>None</code> <code>restart_option</code> <code>Optional[ServiceRestartOption]</code> <p>Restart option. Default is             'RESTART_IF_NEEDED'.</p> <code>'RESTART_IF_NEEDED'</code> <code>services</code> <code>Optional[list[ServiceRestartServices]]</code> <p>List of services to restart.                                                Default is None.</p> <code>None</code> <code>user_name</code> <code>Optional[str]</code> <p>Username. Default is None.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>RequestException</code> <p>If there is an error sending the restart request.</p> <p>Examples:</p>"},{"location":"classes/nios/service/#ibx_sdk.nios.service.NiosServiceMixin.service_restart--restart-services-in-a-group","title":"Restart services in a group","text":"<p>service_restart(groups=['group_name'])</p>"},{"location":"classes/nios/service/#ibx_sdk.nios.service.NiosServiceMixin.service_restart--restart-services-of-specific-members","title":"Restart services of specific members","text":"<p>service_restart(members=['member1', 'member2'])</p>"},{"location":"classes/nios/service/#ibx_sdk.nios.service.NiosServiceMixin.service_restart--restart-services-with-a-specific-restart-mode","title":"Restart services with a specific restart mode","text":"<p>service_restart(mode=ServiceRestartMode.IMMEDIATE)</p>"},{"location":"classes/nios/service/#ibx_sdk.nios.service.NiosServiceMixin.service_restart--restart-services-with-a-specific-restart-option","title":"Restart services with a specific restart option","text":"<p>service_restart(restart_option=ServiceRestartOption.RESTART_IF_NEEDED)</p>"},{"location":"classes/nios/service/#ibx_sdk.nios.service.NiosServiceMixin.service_restart--restart-specific-services","title":"Restart specific services","text":"<p>service_restart(services=[ServiceRestartServices.SERVICE_NAME1, ServiceRestartServices.SERVICE_NAME2])</p>"},{"location":"classes/nios/service/#ibx_sdk.nios.service.NiosServiceMixin.service_restart--restart-services-for-a-specific-user","title":"Restart services for a specific user","text":"<p>service_restart(user_name='username')</p> Source code in <code>src/ibx_sdk/nios/service.py</code> <pre><code>def service_restart(\n    self,\n    groups: Optional[list] = None,\n    members: Optional[list[str]] = None,\n    mode: Optional[RestartMode] = None,\n    restart_option: Optional[RestartOption] = \"RESTART_IF_NEEDED\",\n    services: Optional[list[RestartServices]] = None,\n    user_name: Optional[str] = None,\n) -&gt; None:\n    \"\"\"\n    Restarts specified services on the grid.\n\n    Args:\n        self (Gift): Gift object\n        groups (Optional[list]): List of group names. Default is None.\n        members (Optional[list[str]]): List of member names. Default is None.\n        mode (Optional[ServiceRestartMode]): Restart mode. Default is None.\n        restart_option (Optional[ServiceRestartOption]): Restart option. Default is\n                        'RESTART_IF_NEEDED'.\n        services (Optional[list[ServiceRestartServices]]): List of services to restart.\n                                                           Default is None.\n        user_name (Optional[str]): Username. Default is None.\n\n    Returns:\n        None\n\n    Raises:\n        requests.exceptions.RequestException: If there is an error sending the restart request.\n\n    Examples:\n        # Restart services in a group\n        service_restart(groups=['group_name'])\n\n        # Restart services of specific members\n        service_restart(members=['member1', 'member2'])\n\n        # Restart services with a specific restart mode\n        service_restart(mode=ServiceRestartMode.IMMEDIATE)\n\n        # Restart services with a specific restart option\n        service_restart(restart_option=ServiceRestartOption.RESTART_IF_NEEDED)\n\n        # Restart specific services\n        service_restart(services=[ServiceRestartServices.SERVICE_NAME1,\n        ServiceRestartServices.SERVICE_NAME2])\n\n        # Restart services for a specific user\n        service_restart(user_name='username')\n    \"\"\"\n    data = {}\n    if groups:\n        data[\"groups\"] = [groups]\n    if members:\n        data[\"members\"] = [members]\n    if mode:\n        data[\"mode\"] = mode\n    if restart_option:\n        data[\"restart_option\"] = restart_option\n    if services:\n        data[\"services\"] = [services]\n    if user_name:\n        data[\"user_name\"] = user_name\n\n    logging.debug(pprint.pformat(data))\n\n    try:\n        res = self.post(\n            self.grid_ref, params={\"_function\": \"restartservices\"}, json=data\n        )\n        logging.debug(res.text)\n        res.raise_for_status()\n    except requests.exceptions.RequestException as err:\n        logging.error(err)\n        raise WapiRequestException(err)\n    else:\n        logging.info(\"successfully restarted %s services\", data.get(\"services\"))\n</code></pre>"},{"location":"classes/nios/service/#ibx_sdk.nios.service.NiosServiceMixin.update_service_status","title":"<code>update_service_status(services='ALL')</code>","text":"<p>Updates the status of a service.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <code>Gift</code> <p>The instance of the class.</p> required <code>services</code> <code>str</code> <p>The service option to update the status for. Default value is 'ALL'.</p> <code>'ALL'</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Raises:</p> Type Description <code>RequestException</code> <p>If an error occurs while making the request.</p> Source code in <code>src/ibx_sdk/nios/service.py</code> <pre><code>def update_service_status(self, services: str = \"ALL\") -&gt; None:\n    \"\"\"\n    Updates the status of a service.\n\n    Args:\n        self (Gift): The instance of the class.\n        services (str): The service option to update the status for. Default value is 'ALL'.\n\n    Returns:\n        None\n\n    Raises:\n        requests.exceptions.RequestException: If an error occurs while making the request.\n    \"\"\"\n    payload = {\"service_option\": services}\n    try:\n        res = self.post(\n            self.grid_ref,\n            params={\"_function\": \"requestrestartservicestatus\"},\n            json=payload,\n        )\n        logging.debug(res.text)\n        res.raise_for_status()\n    except requests.exceptions.RequestException as err:\n        logging.error(err)\n        raise WapiRequestException(err)\n</code></pre>"},{"location":"examples/","title":"Infoblox Example Tools","text":"<p>We believe that users can simplify their Infoblox Management with these Python Command-Line Utilities.</p> <p>These tools are a basic powerful suite of Python command-line utilities tailored to enhance the experience with Infoblox Grid Manager using the Infoblox Web API (WAPI). These tools are designed to cater to the needs of both Infoblox administrators and users, offering efficient ways to interact with Infoblox data.</p> <p>Infoblox NIOS stands as a robust DDI (DNS, DHCP, and IPAM) platform, and these utilities are here to make various tasks more accessible, including data manipulation, log retrieval, backup creation, configuration restoration, and protocol service management. By harnessing the capabilities of these tools, you can streamline your daily Infoblox operations, making them smoother and more effective.</p> <p>Customization: These tools are highly adaptable and can be tailored to meet specific requirements, ensuring that they remain versatile for your unique use cases.</p> <p>Let's delve into each of these tools, understanding their purpose and capabilities:</p> <ol> <li> <p>CSV Export Tool</p> <ul> <li>Export data from Infoblox Grid Manager to CSV format.</li> <li>Define parameters like Grid Manager address, output file name, and authentication credentials.</li> <li>Choose the Infoblox WAPI version and specify the type of data objects to export.</li> <li>CSV Export Tool Details</li> </ul> </li> <li> <p>CSV Import Tool</p> <ul> <li>Import data into Infoblox Grid Manager from CSV files.</li> <li>Configure parameters such as Grid Manager address, import file name, and operation type   (INSERT, OVERRIDE, MERGE, DELETE, CUSTOM).</li> <li>Fine-tune imports with optional parameters and debugging capabilities.</li> <li>CSV Import Tool Details</li> </ul> </li> <li> <p>Get File Tool</p> <ul> <li>Retrieve configuration files from an Infoblox Grid Manager.</li> <li>Specify the Grid Manager address, target member, and configuration type.</li> <li>Tailor the retrieval process with optional parameters such as admin username and debugging   options.</li> <li>Get File Tool Details</li> </ul> </li> <li> <p>Get Log Tool</p> <ul> <li>Retrieve logs from an Infoblox Grid Manager, including syslog data.</li> <li>Set parameters for Grid Manager address, target member, log type, and additional   customizations.</li> <li>Enable debugging and adapt log retrieval to your specific needs.</li> <li>Get Log Tool Details</li> </ul> </li> <li> <p>Get Support Bundle Tool</p> <ul> <li>Assemble a Support Bundle from an Infoblox Grid Manager.</li> <li>Input vital parameters, including Grid Manager address and target member.</li> <li>Add optional parameters such as admin username, log file inclusion, and debugging options.</li> <li>Get Support Bundle Tool Details</li> </ul> </li> <li> <p>Grid Backup Tool</p> <ul> <li>Create backups of an Infoblox NIOS Grid.</li> <li>Specify Grid Manager address and backup file name.</li> <li>Customize the backup process with optional parameters to fit your needs.</li> <li>Grid Backup Tool Details</li> </ul> </li> <li> <p>Grid Restore Tool</p> <ul> <li>Restore an Infoblox NIOS Grid from a backup.</li> <li>Configure parameters like Grid Manager's IP or hostname, backup filename, restoration mode,   and IP configuration options.</li> <li>Access debugging capabilities for advanced operations.</li> <li>Grid Restore Tool Details</li> </ul> </li> <li> <p>Restart Service Tool</p> <ul> <li>Restart Infoblox NIOS Protocol Services.</li> <li>Select the Grid Manager address and the specific service(s) to restart.</li> <li>Further, customize with optional parameters and debugging features.</li> <li>Restart Service Tool Details</li> </ul> </li> <li> <p>Service Status Tool</p> <ul> <li>Check the status of Infoblox NIOS Protocol Services.</li> <li>Input essential parameters, such as the Grid Manager's address.</li> <li>Enhance control with optional parameters like admin username and WAPI version.</li> <li>Service Status Tool Details</li> </ul> </li> </ol> <p>Each of these tools simplifies a specific aspect of Infoblox management, offering flexibility and customization options to meet your unique requirements. Whether you're an Infoblox administrator or a user working with Infoblox data, these utilities will become valuable assets in your daily operations.</p>"},{"location":"examples/csvexport/","title":"CSV Export","text":""},{"location":"examples/csvexport/#overview","title":"Overview","text":"<p>This program is a command-line utility designed to simplify the process of exporting data from an Infoblox Grid Manager.</p>"},{"location":"examples/csvexport/#usage","title":"Usage","text":"<p>To invoke the usage run <code>csvexport --help</code></p> <pre><code>Usage: csvexport [OPTIONS]\n\n  CSV Export by object\n\nOptions:\n  Required Parameters: \n    -g, --grid-mgr TEXT  Infoblox Grid Manager  [required]\n    -f, --file TEXT      Infoblox WAPI CSV export file name  [required]\n  Optional Parameters: \n    -u, --username TEXT  Infoblox admin username  [default: admin]\n    -w, --wapi-ver TEXT  Infoblox WAPI version  [default: 2.11]\n    -o, --object TEXT    WAPI export object type\n  Logging Parameters: \n    --debug              enable verbose debug output\n  -h, --help             Show this message and exit.\n</code></pre>"},{"location":"examples/csvexport/#example","title":"Example","text":""},{"location":"examples/csvexport/#csv-export_1","title":"CSV Export","text":"<pre><code>csvexport -u admin -g 192.168.1.2 -f ibcsv-networks.csv -o network\n</code></pre> <p>The command invokes the CSV Job Manager and creates a job to export objects of type network. Once the job is complete, the data is exported and saved.</p> <p>Screen output from command</p> <pre><code>Enter password for [admin]:\n2023-12-09 12:36:27 [nios_csvexport.py:88] INFO connected to Infoblox grid manager 192.168.1.2\n2023-12-09 12:36:27 [fileop.py:154] INFO performing csv export for network object(s)\n2023-12-09 12:36:27 [fileop.py:177] INFO downloading data from https://192.168.1.2/http_direct_file_io/req_id-DOWNLOAD-1209183627629530/Networks.csv\n2023-12-09 12:36:27 [fileop.py:187] INFO writing data to ibcsv_networks.csv file\n2023-12-09 12:36:27 [fileop.py:719] INFO file ibcsv_networks.csv download complete\n</code></pre> <p>Output from ibcsv-networks.csv</p> <pre><code>header-network,address*,netmask*,always_update_dns,basic_polling_settings,boot_file,boot_server,broadcast_address,comment,ddns_domainname,ddns_ttl,deny_bootp,dhcp_members,disabled,discovery_exclusion_range,discovery_member,domain_name,domain_name_servers,enable_ddns,enable_discovery,enable_option81,enable_pxe_lease_time,enable_threshold_email_warnings,enable_threshold_snmp_warnings,enable_thresholds,generate_hostname,ignore_client_requested_options,is_authoritative,lease_scavenge_time,lease_time,mgm_private,network_view,next_server,option_logic_filters,pxe_lease_time,range_high_water_mark,range_high_water_mark_reset,range_low_water_mark,range_low_water_mark_reset,recycle_leases,routers,threshold_email_addresses,update_dns_on_lease_renewal,update_static_leases,vlans,zone_associations\nnetwork,100.64.50.0,255.255.255.0,,,,,,,,,,ns1.ffy.network,False,,nd.ffy.network,ffy.corp,\"100.64.50.53,100.64.50.54\",,True,,,False,False,,,,,,,False,default,,,,95,85,0,10,,100.64.50.1,,,,,&lt;empty&gt;\nnetwork,100.64.40.0,255.255.255.0,,,,,,,,,,,False,,nd.ffy.network,,,,True,,,False,False,,,,,,,False,default,,,,95,85,0,10,,,,,,,&lt;empty&gt;\n</code></pre>"},{"location":"examples/csvimport/","title":"CSV Import","text":""},{"location":"examples/csvimport/#overview","title":"Overview","text":"<p>This program is a command-line utility designed to simplify the process of importing csv data into a Grid Manager.</p>"},{"location":"examples/csvimport/#usage","title":"Usage","text":"<pre><code>Usage: csvimport [OPTIONS]\n\n  CSV Import Data\n\nOptions:\n  Required Parameters: \n    -g, --grid-mgr TEXT           Infoblox Grid Manager  [required]\n    -f, --file TEXT               Infoblox WAPI CSV import file name  [required]\n    -o, --operation [INSERT|OVERRIDE|MERGE|DELETE|CUSTOM]\n                                  CSV import mode  [required]\n  Optional Parameters: \n    -u, --username TEXT           Infoblox admin username  [default: admin]\n    -w, --wapi-ver TEXT           Infoblox WAPI version  [default: 2.11]\n  Logging Parameters: \n    --debug                       enable verbose debug output\n  -h, --help                      Show this message and exit.\n</code></pre>"},{"location":"examples/csvimport/#examples","title":"Examples","text":""},{"location":"examples/csvimport/#csv-import_1","title":"CSV Import","text":"<pre><code>csvimport -u admin -g 192.168.1.2 -o INSERT -f ibcsv_add_network.csv\n</code></pre> <p>The command invokes the CSV Job Manager and creates a job to import objects using the INSERT Operation.</p> <pre><code>csvimport -u admin -g 192.168.1.2 -o INSERT -f ibcsv_add_network.csv\nEnter password for [admin]: \n2023-12-09 16:23:07 [nios_csvimport.py:91] INFO connected to Infoblox grid manager 192.168.1.2\n2023-12-09 16:23:07 [fileop.py:243] INFO step 1 - request uploadinit ibcsv_add_network.csv\n2023-12-09 16:23:07 [fileop.py:266] INFO step 2 - post the files using the upload_url provided\n2023-12-09 16:23:07 [fileop.py:276] INFO step 3 - execute the csv_import INSERT job on ibcsv_add_network.csv\n</code></pre> <p>Sample CSV File</p> <pre><code>header-network,address*,netmask*,dhcp_members,disabled,domain_name,domain_name_servers,network_view,routers\nnetwork,192.168.1.0,255.255.255.0,ns1.ffy.network,FALSE,ffy.corp,\"100.64.50.53,100.64.50.54\",default,192.168.1.1\n</code></pre>"},{"location":"examples/csvimport/#csv-delete","title":"CSV Delete","text":"<pre><code>csvimport -u admin -g 192.168.1.2 -o DELETE -f ibcsv_add_network.csv\n</code></pre> <p>The command invokes the CSV Job Manager and creates a job to delete objects using the DELETE Operation.</p> <p>Screen output from command</p> <pre><code>csvimport -u admin -g 192.168.1.2 -o DELETE -f ibcsv_delete_network.csv\nEnter password for [admin]: \n2023-12-09 16:23:07 [nios_csvimport.py:91] INFO connected to Infoblox grid manager 192.168.1.2\n2023-12-09 16:23:07 [fileop.py:243] INFO step 1 - request uploadinit ibcsv_delete_network.csv\n2023-12-09 16:23:07 [fileop.py:266] INFO step 2 - post the files using the upload_url provided\n2023-12-09 16:23:07 [fileop.py:276] INFO step 3 - execute the csv_import DELETE job on ibcsv_delete_network.csv\n</code></pre> <p>Sample CSV File</p> <pre><code>header-network,address*,netmask*\nnetwork,192.168.1.0,255.255.255.0\n</code></pre>"},{"location":"examples/csvimport/#csv-multiple-action","title":"CSV Multiple Action","text":"<pre><code>csvimport -u admin -g 192.168.1.2 -o CUSTOM -f ibcsv_networks.csv \n</code></pre> <p>The command invokes the CSV Job Manager and creates a job to take specific actions for objects using the Multiple Action CUSTOM Operation.</p> <p>Screen output from command</p> <pre><code>csvimport -u admin -g 192.168.1.2 -o CUSTOM -f ibcsv_network.csv\nEnter password for [admin]: \n2023-12-09 14:35:20 [nios_csvimport.py:91] INFO connected to Infoblox grid manager 192.168.1.2\n2023-12-09 14:35:20 [fileop.py:243] INFO step 1 - request uploadinit ibcsv_networks.csv\n2023-12-09 14:35:20 [fileop.py:266] INFO step 2 - post the files using the upload_url provided\n2023-12-09 14:35:20 [fileop.py:276] INFO step 3 - execute the csv_import CUSTOM job on ibcsv_networks.csv\n</code></pre> <p>Sample CSV File</p> <pre><code>header-network,IMPORT-ACTION,address*,netmask*,dhcp_members,disabled,discovery_member,domain_name,domain_name_servers,network_view,routers\nnetwork,O,100.64.50.0,255.255.255.0,ns1.ffy.network,FALSE,nd.ffy.network,ffy.corp,\"100.64.50.53,100.64.50.54\",default,100.64.50.1\nnetwork,O,100.64.40.0,255.255.255.0,,FALSE,nd.ffy.network,,,default,\n</code></pre> <p>Importing Multiple Action CSV file</p> <p>When you import data, you can include multiple actions, such as add, modify, and delete, in one single CSV file. The multiple action CSV import file contains multiple types of objects with its headers and data rows listed in the order of their dependency hierarchy.</p> <p>The CSV import option supports insert, merge/override and delete operations. To combine these operations together in a single CSV file, you must specify an optional <code>IMPORT-ACTION</code> column in the CSV import file. The column value for each data row describes the type of action that the appliance supports for the respective row.</p> Action Description Notes I Insert If it exists, an error will be generated. M Merge If it exists, additional fields will be merged into the record. If the object does not exist, you must first perform the insert operation to add the data. O Override If it exists, all fields will be overridden. If the object does not exist, you must first perform the insert operation to add the data. IM Insert + Merge The appliance first checks if the corresponding object exists. If it exists, the appliance performs the merge or override operation accordingly. IO Insert + Override The appliance first checks if the corresponding object exists. If it exists, the appliance performs the merge or override operation accordingly. D Delete If it exists, record will be deleted.  If it does not exists, an error will be generated. <p>Warning</p> <p>CSV imports and operations that involve massive data, such as deleting large zones and recursive deletion of networks and all child objects, will significantly affect member performance, resulting in service outage.</p> <pre><code>sequenceDiagram\n  autonumber\n  Client-&gt;&gt;NIOS: wapi.connect()\n  NIOS-&gt;&gt;Client: cookies['ibapauth']\n  Client-&gt;&gt;FileOp: wapi.csv_import()\n  loop file operation tasks\n    FileOp-&gt;&gt;FileOp: __upload_init()\n    FileOp-&gt;&gt;FileOp: __csv_import_file()\n    FileOp-&gt;&gt;FileOp: __csv_import()\n  end\n  FileOp-&gt;&gt;Client: csvtask</code></pre>"},{"location":"examples/generate_csr/","title":"Generate CSR","text":""},{"location":"examples/generate_csr/#overview","title":"Overview","text":"<p>This program is a command-line utility designed to simplify the process of generating an SSL Certificate Signing Request or CSR from an Infoblox Grid Manager.</p>"},{"location":"examples/generate_csr/#usage","title":"Usage","text":"<p>To invoke the usage run <code>generate-csr --help</code></p> <pre><code>Usage: generate-csr [OPTIONS]\n\n  Get NIOS Log from Member\n\nOptions:\n  Required Parameters:\n    -g, --grid-mgr TEXT           Infoblox Grid Manager  [required]\n    -n, --common-name TEXT        Common Name for the certificate  [required]\n    -m, --member TEXT             Member for the certificate  [required]\n  Optional Parameters:\n    -u, --username TEXT           Infoblox admin username  [default: admin]\n    -w, --wapi-ver TEXT           Infoblox WAPI version  [default: 2.11]\n  Optional Certificate Parameters:\n    -a, --algorithm [SHA-256|SHA-384|SHA-512]\n                                  The digest algorithm  [default: SHA-256]\n    --certificate-usage [ADMIN|CAPTIVE_PORTAL|SFNT_CLIENT_CERT|IFMAP_DHCP]\n                                  Certificate Usage  [default: ADMIN]\n    -c, --comment TEXT            Certificate comment\n    --country TEXT                Certificate country  [default: US]\n    -e, --email TEXT              Certificate email address\n    -k, --key-size INTEGER        Certificate key size  [default: 2048]\n    -l, --locality TEXT           Certificate locality\n    -o, --organization TEXT       Certificate organization\n    --ou TEXT                     Certificate organizational unit\n    -s, --state TEXT              Certificate state\n    --san TEXT                    Certificate subject alternative name(s) as [TYPE/VALUE,...]\n  Logging Parameters:\n    --debug                       enable verbose debug output\n  -h, --help                      Show this message and exit.\n</code></pre>"},{"location":"examples/generate_csr/#example","title":"Example","text":""},{"location":"examples/generate_csr/#csv-export","title":"CSV Export","text":"<pre><code>csvexport -u admin -g 192.168.1.2 -n gm.example.com -m ibxgm.example.com -s 'DNS/ibxgm.example.com,IP/192.168.1.2'\n</code></pre> <p>The above command will create a CSR or certificate signing request for the member <code>ibxgm.example.com</code> with a common name set to <code>gm.example.com</code> the SAN or Subject Alternative Names will include <code>ibxgm.example.com</code> and <code>192.168.1.2</code> in the CSR. Once complete, the CSR is downloaded from the grid and saved as <code>cert.pem</code>.</p> <p>Screen output from command</p> <pre><code>Enter password for [admin]:\n2024-11-09 15:14:14 [nios_gen_csr.py:152] INFO connected to Infoblox grid manager 192.168.1.2\n2024-11-09 15:14:14 [fileop.py:309] INFO generating ADMIN csr for gm.example.com\n2024-11-09 15:14:18 [fileop.py:354] INFO downloading data from https://192.168.1.2/http_direct_file_io/req_id-DOWNLOAD-1109221418162387/cert.pem\n2024-11-09 15:14:18 [fileop.py:831] INFO https://192.168.1.2/http_direct_file_io/req_id-DOWNLOAD-1109221418162387/cert.pem\n2024-11-09 15:14:19 [fileop.py:924] INFO writing file: cert.pem\n2024-11-09 15:14:19 [fileop.py:822] INFO file cert.pem download complete\n2024-11-09 15:14:19 [nios_gen_csr.py:185] INFO finished!\n</code></pre>"},{"location":"examples/get_file/","title":"Get File","text":""},{"location":"examples/get_file/#overview","title":"Overview","text":"<p>This Python program is a command-line utility designed to retrieve configuration files from the  Grid.</p>"},{"location":"examples/get_file/#usage","title":"Usage","text":"<pre><code>Usage: get-file [OPTIONS]\n\n  Get NIOS File\n\nOptions:\n  Required Parameters: \n    -g, --grid-mgr TEXT  Infoblox Grid Manager  [required]\n    -m, --member TEXT    Member to retrieve file from  [required]\n  Optional Parameters: \n    -u, --username TEXT  Infoblox admin username  [default: admin]\n    -t, --cfg-type TEXT  Configuration Type: DNS_CACHE | DNS_CFG | DHCP_CFG | DHCPV6_CFG |\n                         TRAFFIC_CAPTURE_FILE | DNS_STATS | DNS_RECURSING_CACHE  [default:\n                         DNS_CFG]\n    -w, --wapi-ver TEXT  Infoblox WAPI version  [default: 2.11]\n  Logging Parameters: \n    --debug              enable verbose debug output\n  -h, --help             Show this message and exit.\n</code></pre>"},{"location":"examples/get_file/#examples","title":"Examples","text":""},{"location":"examples/get_file/#dns-configuration-download","title":"DNS Configuration Download","text":"<p>The following example will download the named.conf file from the infoblox.localdomain.</p> <pre><code>get-file -u admin -g 192.168.1.2 -m infoblox.localdomain -t DNS_CFG\n</code></pre> <p>Screen output from command</p> <pre><code>get-file -u admin -g 192.168.1.2 -m infoblox.localdomain -t DNS_CFG \nEnter password for [admin]: \n2023-12-09 16:56:51 [nios_get_file.py:94] INFO connected to Infoblox grid manager 192.168.1.2\n2023-12-09 16:56:51 [fileop.py:65] INFO fetching DNS_CFG config file for grid member infoblox.localdomain\n2023-12-09 16:56:51 [fileop.py:91] INFO downloading data from https://192.168.1.2/http_direct_file_io/req_id-DOWNLOAD-1209225651240725/dnsConf.tar.gz\n2023-12-09 16:56:51 [fileop.py:100] INFO writing data to dnsconf.tar.gz file\n2023-12-09 16:56:51 [fileop.py:719] INFO file dnsconf.tar.gz download complete\n2023-12-09 16:56:51 [nios_get_file.py:98] INFO finished!\n</code></pre>"},{"location":"examples/get_file/#dhcp-configuration-download","title":"DHCP Configuration Download","text":"<p>The following example will download the dhcpd.conf file from the infoblox.localdomain.</p> <pre><code>get-file -u admin -g 192.168.1.2 -m infoblox.localdomain -t DHCP_CFG\n</code></pre> <p>Screen output from command</p> <pre><code>get-file -u admin -g 192.168.1.2 -m ns1.ffy.network -t DHCP_CFG          \nEnter password for [admin]: \n2023-12-09 16:54:44 [nios_get_file.py:94] INFO connected to Infoblox grid manager 192.168.1.2\n2023-12-09 16:54:44 [fileop.py:65] INFO fetching DHCP_CFG config file for grid member infoblox.localdomain\n2023-12-09 16:54:44 [fileop.py:91] INFO downloading data from https://192.168.1.2/http_direct_file_io/req_id-DOWNLOAD-1209225444728578/dhcpConf.tar.gz\n2023-12-09 16:54:45 [fileop.py:100] INFO writing data to dhcpconf.tar.gz file\n2023-12-09 16:54:45 [fileop.py:719] INFO file dhcpconf.tar.gz download complete\n2023-12-09 16:54:45 [nios_get_file.py:98] INFO finished!\n</code></pre>"},{"location":"examples/get_file/#dhcpv6-configuration-download","title":"DHCPV6 Configuration Download","text":"<p>The following example will download the dhcpv6.conf file from the infoblox.localdomain.</p> <pre><code>get-file -u admin -g 192.168.1.2 -m infoblox.localdomain -t DHCPV6_CFG\n</code></pre> <p>Screen output from command</p> <pre><code>get-file -u admin -g 192.168.1.2 -m ns1.ffy.network -t DHCPV6_CFG        \nEnter password for [admin]: \n2023-12-09 17:03:59 [nios_get_file.py:94] INFO connected to Infoblox grid manager 192.168.1.2\n2023-12-09 17:03:59 [fileop.py:65] INFO fetching DHCPV6_CFG config file for grid member infoblox.localdomain\n2023-12-09 17:04:00 [fileop.py:91] INFO downloading data from https://192.168.1.2/http_direct_file_io/req_id-DOWNLOAD-1209230400019222/dhcpv6Conf.tar.gz\n2023-12-09 17:04:00 [fileop.py:100] INFO writing data to dhcpv6conf.tar.gz file\n2023-12-09 17:04:00 [fileop.py:719] INFO file dhcpv6conf.tar.gz download complete\n2023-12-09 17:04:00 [nios_get_file.py:98] INFO finished!\n</code></pre>"},{"location":"examples/get_file/#dns-states","title":"DNS States","text":"<p>The following example will download the named.stats file from the infoblox.localdomain.</p> <pre><code>get-file -u admin -g 192.168.1.2 -m infoblox.localdomain -t DNS_STATS\n</code></pre> <p>Screen output from command</p> <pre><code>get-file -u admin -g 192.168.1.2 -m ns1.ffy.network -t DNS_STATS \nEnter password for [admin]: \n2023-12-09 17:05:10 [nios_get_file.py:94] INFO connected to Infoblox grid manager 192.168.1.2\n2023-12-09 17:05:10 [fileop.py:65] INFO fetching DNS_STATS config file for grid member infoblox.localdomain\n2023-12-09 17:05:11 [fileop.py:91] INFO downloading data from https://192.168.1.2/http_direct_file_io/req_id-DOWNLOAD-1209230510855236/dnsStats.tar.gz\n2023-12-09 17:05:11 [fileop.py:100] INFO writing data to dnsstats.tar.gz file\n2023-12-09 17:05:11 [fileop.py:719] INFO file dnsstats.tar.gz download complete\n2023-12-09 17:05:11 [nios_get_file.py:98] INFO finished!\n</code></pre> <p>Warning</p> <p>Configuration files can only be downloaded if the file exists on the appliance. If the file  does not exist a \"400 Client Error: Bad Request for url\" will be received.</p>"},{"location":"examples/get_log/","title":"Get Log","text":""},{"location":"examples/get_log/#overview","title":"Overview","text":"<p>This program is a command-line utility designed to retrieve log files from  the Grid.</p>"},{"location":"examples/get_log/#usage","title":"Usage","text":"<pre><code>Usage: get-log [OPTIONS]\n\n  Get NIOS Log from Member\n\nOptions:\n  Required Parameters: \n    -g, --grid-mgr TEXT           Infoblox Grid Manager  [required]\n    -m, --member TEXT             Member to retrieve log from  [required]\n  Optional Parameters: \n    -u, --username TEXT           Infoblox admin username  [default: admin]\n    -t, --log-type LOG_TYPE       select log type  [default: SYSLOG]\n    -n, --node-type [ACTIVE|PASSIVE]\n                                  Node: ACTIVE | PASSIVE  [default: ACTIVE]\n    -r, --rotated-logs            Exclude Rotated Logs\n    -w, --wapi-ver TEXT           Infoblox WAPI version  [default: 2.11]\n  Logging Parameters: \n    --debug                       enable verbose debug output\n  -h, --help                      Show this message and exit.\n</code></pre>"},{"location":"examples/get_log/#examples","title":"Examples","text":""},{"location":"examples/get_log/#syslog-download","title":"Syslog Download","text":"<p>The following example will download the SYSLOG file from the infoblox.localdomain.</p> <pre><code>get-log -u admin -g 192.168.1.2 -u admin -m infoblox.localdomain -t SYSLOG\n</code></pre> <p>Screen output from command</p> <pre><code>get-log -u admin -g 192.168.1.2 -m infoblox.localdomain -t SYSLOG\nEnter password for [admin]: \n2023-12-09 17:13:42 [nios_get_log.py:108] INFO connected to Infoblox grid manager 192.168.1.2\n2023-12-09 17:13:42 [fileop.py:982] INFO fetching SYSLOG log files for infoblox.localdomain\n2023-12-09 17:13:48 [fileop.py:1019] INFO downloading data from https://192.168.1.2/http_direct_file_io/req_id-DOWNLOAD-1209231342096359/sysLog.tar.gz\n2023-12-09 17:13:48 [fileop.py:1029] INFO writing data to 2023120948-infoblox.localdomain-SYSLOG.tgz file\n2023-12-09 17:13:51 [fileop.py:719] INFO file 2023120948-infoblox.localdomain-SYSLOG.tgz download complete\n2023-12-09 17:13:51 [nios_get_log.py:115] INFO finished!\n</code></pre>"},{"location":"examples/get_log/#audit-log-download","title":"Audit Log Download","text":"<p>The following example will download the AUDITLOG file from the infoblox.localdomain.</p> <pre><code>get-log -u admin -g 192.168.1.2 -u admin -m infoblox.localdomain -t AUDITLOG\n</code></pre> <p>Screen output from command</p> <pre><code>get-log -u admin -g 192.168.1.2 -u admin -m infoblox.localdomain -t AUDITLOG\nEnter password for [admin]: \n2023-12-09 19:13:02 [nios_get_log.py:122] INFO connected to Infoblox grid manager 192.168.1.2\n2023-12-09 19:13:02 [fileop.py:1008] INFO fetching AUDITLOG log files for infoblox.localdomain\n2023-12-09 19:13:02 [fileop.py:1045] INFO downloading data from https://192.168.1.2/http_direct_file_io/req_id-DOWNLOAD-1210011302085953/auditLog.tar.gz\n2023-12-09 19:13:02 [fileop.py:675] INFO https://192.168.1.2/http_direct_file_io/req_id-DOWNLOAD-1210011302085953/auditLog.tar.gz\n2023-12-09 19:13:02 [fileop.py:41] INFO writing file: 2023120902-infoblox.localdomain-AUDITLOG.tgz\n2023-12-09 19:13:02 [fileop.py:727] INFO file 2023120902-infoblox.localdomain-AUDITLOG.tgz download complete\n2023-12-09 19:13:02 [nios_get_log.py:129] INFO finished!\n</code></pre>"},{"location":"examples/get_supportbundle/","title":"Get Support Bundle","text":""},{"location":"examples/get_supportbundle/#overview","title":"Overview","text":"<p>This program is a command-line utility designed to retrieve support-bundles from the Grid.</p>"},{"location":"examples/get_supportbundle/#usage","title":"Usage","text":"<pre><code>Usage: get-supportbundle [OPTIONS]\n\n  Retrieve Support Bundle from Member\n\nOptions:\n  Required Parameters: \n    -g, --grid-mgr TEXT  Infoblox Grid Manager  [required]\n    -m, --member TEXT    Member to retrieve log from  [required]\n  Optional Parameters: \n    -u, --username TEXT  Infoblox admin username  [default: admin]\n    -r, --rotated-logs   Include Rotated Logs\n    -l, --log-files      Include Log Files\n    -w, --wapi-ver TEXT  Infoblox WAPI version  [default: 2.11]\n  Logging Parameters: \n    --debug              enable verbose debug output\n  -h, --help             Show this message and exit.\n</code></pre>"},{"location":"examples/get_supportbundle/#example","title":"Example","text":""},{"location":"examples/get_supportbundle/#support-bundle-download","title":"Support Bundle Download","text":"<p>The following example will download the supportbundle with rotated logs and log files from the infoblox.localdomain.</p> <pre><code>get-supportbundle -u admin -g 192.168.1.2 -m infoblox.localdomain -r -l\n</code></pre> <p>Screen output from command</p> <pre><code>et-supportbundle -g 192.168.1.2 -m ns1.ffy.network -r -l\nEnter password for [admin]: \n2023-12-09 19:21:32 [nios_get_supportbundle.py:91] INFO connected to Infoblox grid manager 192.168.1.2\n2023-12-09 19:21:32 [fileop.py:918] INFO performing get_support_bundle for ns1.ffy.network object(s)\n2023-12-09 19:22:33 [fileop.py:952] INFO downloading data from https://192.168.1.2/http_direct_file_io/req_id-DOWNLOAD-1210012132961808/supportBundle.tar.gz\n2023-12-09 19:22:33 [fileop.py:675] INFO https://192.168.1.2/http_direct_file_io/req_id-DOWNLOAD-1210012132961808/supportBundle.tar.gz\n2023-12-09 19:22:33 [fileop.py:41] INFO writing file: 2023120933-infoblox.localdomain-SupportBundle.tgz\n2023-12-09 19:22:38 [fileop.py:727] INFO file 2023120933-infoblox.localdomain-SupportBundle.tgz download complete\n2023-12-09 19:22:38 [nios_get_supportbundle.py:99] INFO finished!\n</code></pre>"},{"location":"examples/grid_backup/","title":"Grid Backup","text":""},{"location":"examples/grid_backup/#overview","title":"Overview","text":"<p>This program is a command-line utility designed to retrieve backups from the Grid Manager.</p>"},{"location":"examples/grid_backup/#usage","title":"Usage","text":"<pre><code>Usage: grid-backup [OPTIONS]\n\n  Backup NIOS Grid\n\nOptions:\n  Required Parameters: \n    -g, --grid-mgr TEXT  Infoblox Grid Manager  [required]\n  Optional Parameters: \n    -u, --username TEXT  Infoblox admin username  [default: admin]\n    -f, --file TEXT      Infoblox backup file name  [default: database.bak]\n    -w, --wapi-ver TEXT  Infoblox WAPI version  [default: 2.11]\n  Logging Parameters: \n    --debug              enable verbose debug output\n  -h, --help             Show this message and exit.\n</code></pre>"},{"location":"examples/grid_backup/#example","title":"Example","text":""},{"location":"examples/grid_backup/#create-and-download-grid-backup","title":"Create and Download Grid Backup","text":"<p>The following example will download backup of the Grid Manager.</p> <pre><code>grid-backup -u admin -g 192.168.1.2 -f database.bak\n</code></pre> <p>Screen output from command</p> <pre><code>grid-backup -u admin -g 192.168.1.2 -f database.bak\nEnter password for [admin]: \n2023-12-09 20:40:55 [nios_grid_backup.py:85] INFO connected to Infoblox grid manager 192.168.1.2\n2023-12-09 20:40:55 [fileop.py:618] INFO step 1 - request gridbackup database.bak\n2023-12-09 20:40:58 [fileop.py:628] INFO step 2 - saving backup to database.bak\n2023-12-09 20:40:58 [fileop.py:675] INFO https://192.168.1.2/http_direct_file_io/req_id-DOWNLOAD-1210024055568763/database.bak\n2023-12-09 20:40:58 [fileop.py:41] INFO writing file: database.bak\n2023-12-09 20:40:59 [fileop.py:727] INFO file database.bak download complete\n</code></pre>"},{"location":"examples/grid_restore/","title":"Grid Restore","text":""},{"location":"examples/grid_restore/#overview","title":"Overview","text":"<p>This program is a command-line utility designed to restore backups to a Grid Manager.</p>"},{"location":"examples/grid_restore/#usage","title":"Usage","text":"<pre><code>Usage: grid-restore [OPTIONS]\n\n  Restore NIOS Grid.\n\nOptions:\n  Required Parameters: \n    -g, --grid-mgr TEXT           Infoblox NIOS Grid Manager IP/Hostname  [required]\n    -f, --filename TEXT           Infoblox NIOS Grid restore filename  [required]\n  Optional Parameters: \n    -u, --username TEXT           Infoblox NIOS username\n    -m, --mode [NORMAL|FORCED|CLONE]\n                                  Grid Restore Mode [NORMAL|FORCED|CLONE]  [default: FORCED]\n    -k, --keep                    Keep existing IP otherwise use IP from backup\n    -w, --wapi-ver TEXT           Infoblox WAPI version  [default: 2.11]\n  Logging Parameters: \n    --debug                       Enable verbose logging\n  -h, --help                      Show this message and exit.\n</code></pre>"},{"location":"examples/grid_restore/#examples","title":"Examples","text":""},{"location":"examples/grid_restore/#restore-grid-backup-from-file","title":"Restore Grid Backup from File","text":"<p>The following example will restore a backup a Grid Manager.</p> <pre><code>grid-restore -u admin -g 192.168.1.2 -f database.bak -m NORMAL\n</code></pre> <p>Screen output from command</p> <pre><code>grid-restore -u admin -g 192.168.1.2 -f database.bak -m NORMAL\nEnter password for [admin]: \n2023-12-09 20:45:21 [nios_grid_restore.py:94] INFO connected to Infoblox grid manager 192.168.1.2\n2023-12-09 20:45:21 [fileop.py:830] INFO step 1 - request uploadinit database.bak\n2023-12-09 20:45:22 [fileop.py:846] INFO step 2 - post the files using the upload_url provided\n2023-12-09 20:45:25 [fileop.py:855] INFO step 3 - execute the restore\n2023-12-09 20:45:35 [fileop.py:867] INFO Grid restore successful!\n</code></pre> <p>Danger</p> <p>Restoring an Infoblox Grid should only be considered as a final option for production  deployments. Please refrain from initiating a restoration process unless you are in a Disaster  Recovery (DR) scenario or directed to do so by Infoblox Technical Support.</p>"},{"location":"examples/grid_restore/#restore-grid-backup-from-file-to-a-lab","title":"Restore Grid Backup from file to a Lab","text":"<p>The following example will restore a backup of a Grid Manager to another system (lab).</p> <pre><code>grid-restore -u admin -g 192.168.1.3 -f database.bak -m FORCED -k\n</code></pre> <p>Screen output from command</p> <pre><code>grid-restore -u admin -g 192.168.1.3 -f database.bak -m FORCED -k\nEnter password for [admin]: \n2023-12-09 20:57:51 [nios_grid_restore.py:94] INFO connected to Infoblox grid manager  192.168.1.3\n2023-12-09 20:57:51 [fileop.py:830] INFO step 1 - request uploadinit database.bak\n2023-12-09 20:57:51 [fileop.py:846] INFO step 2 - post the files using the upload_url provided\n2023-12-09 20:57:53 [fileop.py:855] INFO step 3 - execute the restore\n2023-12-09 20:58:02 [fileop.py:867] INFO Grid restore successful!\n</code></pre>"},{"location":"examples/restart_service/","title":"Restart Services","text":""},{"location":"examples/restart_service/#overview","title":"Overview","text":"<p>This program is a command-line utility designed to restart protocol services in Grid.</p>"},{"location":"examples/restart_service/#usage","title":"Usage","text":"<pre><code>Usage: restart-service [OPTIONS]\n\n  Restart NIOS Protocol Services\n\nOptions:\n  Required Parameters: \n    -g, --grid-mgr TEXT           Infoblox Grid Manager  [required]\n  Optional Parameters: \n    -u, --username TEXT           Infoblox admin username  [default: admin]\n    -s, --service [DNS|DHCP|DHCPV4|DHCPV6|ALL]\n                                  select which service to restart  [default: ALL]\n    -w, --wapi-ver TEXT           Infoblox WAPI version  [default: 2.11]\n  Logging Parameters: \n    --debug                       enable verbose debug output\n  -h, --help                      Show this message and exit.\n</code></pre>"},{"location":"examples/restart_service/#example","title":"Example","text":""},{"location":"examples/restart_service/#restart-all-services","title":"Restart ALL Services","text":"<p>The following example restart all services (DNS,DHCP,DHCPV6).</p> <pre><code>grid-restore -u admin -g 192.168.1.2\n</code></pre> <p>Screen output from command</p> <pre><code>restart-service -u admin -g 192.168.1.2 \nEnter password for [admin]: \n2023-12-09 21:04:03 [nios_restart_service.py:89] INFO connected to Infoblox grid manager 192.168.1.2\n2023-12-09 21:04:03 [service.py:65] INFO successfully restarted ['ALL'] services\n</code></pre>"},{"location":"examples/restart_service/#restart-dns-services","title":"Restart DNS Services","text":"<p>The following example restart DNS services.</p> <pre><code>grid-restore -u admin -g 192.168.1.2 -s DNS\n</code></pre> <p>Screen output from command</p> <pre><code> restart-service -u admin -g 192.168.1.2 -s DNS\nEnter password for [admin]: \n2023-12-09 21:04:52 [nios_restart_service.py:89] INFO connected to Infoblox grid manager 192.168.1.2\n2023-12-09 21:04:52 [service.py:65] INFO successfully restarted ['DNS'] services\n</code></pre>"},{"location":"examples/restart_service/#restart-dhcp-services","title":"Restart DHCP Services","text":"<p>The following example restart DHCP services.</p> <pre><code>grid-restore -u admin -g 192.168.1.2 -s DHCP\n</code></pre> <p>Screen output from command</p> <pre><code>restart-service -u admin -g 192.168.1.2 -s DHCP\nEnter password for [admin]: \n2023-12-09 21:05:18 [nios_restart_service.py:89] INFO connected to Infoblox grid manager 192.168.1.2\n2023-12-09 21:05:18 [service.py:65] INFO successfully restarted ['DHCP'] services\n</code></pre>"},{"location":"examples/restart_service/#restart-dhcpv6-services","title":"Restart DHCPV6 Services","text":"<p>The following example restart DHCPV6 services.</p> <pre><code>grid-restore -u admin -g 192.168.1.2 -s DHCPV6\n</code></pre> <p>Screen output from command</p> <pre><code>restart-service -u admin -g 192.168.1.2 -s DHCPV6\nEnter password for [admin]: \n2023-12-09 21:09:10 [nios_restart_service.py:89] INFO connected to Infoblox grid manager 192.168.1.2\n2023-12-09 21:09:10 [service.py:65] INFO successfully restarted ['DHCPV6'] services\n</code></pre>"},{"location":"examples/restart_status/","title":"Restart Status","text":""},{"location":"examples/restart_status/#overview","title":"Overview","text":"<p>This program is a command-line utility designed to retieve the restart services  status from the Grid Manager.</p>"},{"location":"examples/restart_status/#usage","title":"Usage","text":"<pre><code>Usage: restart-status [OPTIONS]\n\n  Retrieve Restart Status\n\nOptions:\n  Required Parameters: \n    -g, --grid-mgr TEXT  Infoblox Grid Manager  [required]\n  Optional Parameters: \n    -u, --username TEXT  Infoblox admin username  [default: admin]\n    -w, --wapi-ver TEXT  Infoblox WAPI version  [default: 2.11]\n  Logging Parameters: \n    --debug              enable verbose debug output\n  -h, --help             Show this message and exit.\n</code></pre>"},{"location":"examples/restart_status/#example","title":"Example","text":"<pre><code>restart-status -u admin -g 192.168.1.2\n</code></pre>"},{"location":"modules/logger/","title":"Logger","text":"<p>Copyright 2023 Infoblox</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p> <pre><code>https://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>"},{"location":"modules/logger/#ibx_sdk.logger.ibx_logger.CallCounted","title":"<code>CallCounted</code>","text":"<p>Decorator to determine the number of calls for a method.</p> <p>This decorator can be used to wrap a method, and each time the method is called, it increments a counter to keep track of the number of times the method has been called.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>callable</code> <p>The method to be decorated.</p> required Source code in <code>src/ibx_sdk/logger/ibx_logger.py</code> <pre><code>class CallCounted:\n    \"\"\"\n    Decorator to determine the number of calls for a method.\n\n    This decorator can be used to wrap a method, and each time the method is called,\n    it increments a counter to keep track of the number of times the method has been\n    called.\n\n    Args:\n        method (callable): The method to be decorated.\n\n    \"\"\"\n\n    def __init__(self, method):\n        \"\"\"\n        Initialize the CallCounted decorator.\n\n        Args:\n            method (callable): The method to be decorated.\n        \"\"\"\n        self.method = method\n        self.counter = 0\n\n    def __call__(self, *args: Any, **kwargs: Any) -&gt; Any:\n        \"\"\"\n        Call the decorated method and increment the call count.\n\n        Args:\n            *args: Positional arguments to pass to the decorated method.\n            **kwargs: Keyword arguments to pass to the decorated method.\n\n        Returns:\n            The result of the decorated method.\n\n        \"\"\"\n        self.counter += 1\n        return self.method(*args, **kwargs)\n</code></pre>"},{"location":"modules/logger/#ibx_sdk.logger.ibx_logger.CallCounted.__call__","title":"<code>__call__(*args, **kwargs)</code>","text":"<p>Call the decorated method and increment the call count.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Positional arguments to pass to the decorated method.</p> <code>()</code> <code>**kwargs</code> <code>Any</code> <p>Keyword arguments to pass to the decorated method.</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>The result of the decorated method.</p> Source code in <code>src/ibx_sdk/logger/ibx_logger.py</code> <pre><code>def __call__(self, *args: Any, **kwargs: Any) -&gt; Any:\n    \"\"\"\n    Call the decorated method and increment the call count.\n\n    Args:\n        *args: Positional arguments to pass to the decorated method.\n        **kwargs: Keyword arguments to pass to the decorated method.\n\n    Returns:\n        The result of the decorated method.\n\n    \"\"\"\n    self.counter += 1\n    return self.method(*args, **kwargs)\n</code></pre>"},{"location":"modules/logger/#ibx_sdk.logger.ibx_logger.CallCounted.__init__","title":"<code>__init__(method)</code>","text":"<p>Initialize the CallCounted decorator.</p> <p>Parameters:</p> Name Type Description Default <code>method</code> <code>callable</code> <p>The method to be decorated.</p> required Source code in <code>src/ibx_sdk/logger/ibx_logger.py</code> <pre><code>def __init__(self, method):\n    \"\"\"\n    Initialize the CallCounted decorator.\n\n    Args:\n        method (callable): The method to be decorated.\n    \"\"\"\n    self.method = method\n    self.counter = 0\n</code></pre>"},{"location":"modules/logger/#ibx_sdk.logger.ibx_logger.increase_log_level","title":"<code>increase_log_level(handler_type='both')</code>","text":"<p>Increase the logging level of the root logger and specific handlers.</p> <p>Parameters:</p> Name Type Description Default <code>handler_type</code> <code>str</code> <p>Specify the type of handlers to increase the logging level for. Can be 'both' (default), 'console', or 'file'.</p> <code>'both'</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Example:</p> <p>Increase Log Level <pre><code>from your_module import increase_log_level\n\n# Increase the logging level for both console and file handlers\nincrease_log_level()\n\n# Increase the logging level for console handlers only - use 'both' to increase the file and\n# console handlers\nincrease_log_level(handler_type='console')\n</code></pre></p> Source code in <code>src/ibx_sdk/logger/ibx_logger.py</code> <pre><code>def increase_log_level(handler_type: str = \"both\") -&gt; None:\n    \"\"\"\n    Increase the logging level of the root logger and specific handlers.\n\n    Args:\n        handler_type (str, optional): Specify the type of handlers to increase\n            the logging level for. Can be 'both' (default), 'console', or 'file'.\n\n    Returns:\n        None\n\n    Example:\n\n    **Increase Log Level**\n    ```python\n    from your_module import increase_log_level\n\n    # Increase the logging level for both console and file handlers\n    increase_log_level()\n\n    # Increase the logging level for console handlers only - use 'both' to increase the file and\n    # console handlers\n    increase_log_level(handler_type='console')\n    ```\n    \"\"\"\n\n    defined_levels = sorted(set(_defined_levels().values()))\n    root_logger = logging.getLogger()\n    current_level = root_logger.getEffectiveLevel()\n    current_index = defined_levels.index(current_level)\n    selected_index = max(0, current_index - 1)\n    root_logger.setLevel(defined_levels[selected_index])\n    for handle in root_logger.handlers:\n        if isinstance(handle, coloredlogs.StandardErrorHandler) and handler_type in [\n            \"both\",\n            \"console\",\n        ]:\n            current_index = defined_levels.index(handle.level)\n            selected_index = max(0, current_index - 1)\n            coloredlogs.set_level(defined_levels[selected_index])\n        elif (\n            isinstance(handle, logging.FileHandler)\n            or isinstance(handle, logging.handlers.RotatingFileHandler)\n            and handler_type in [\"both\", \"file\"]\n        ):\n            current_index = defined_levels.index(handle.level)\n            selected_index = max(0, current_index - 1)\n            handle.setLevel(defined_levels[selected_index])\n</code></pre>"},{"location":"modules/logger/#ibx_sdk.logger.ibx_logger.init_console_logger","title":"<code>init_console_logger(level=None)</code>","text":"<p>Initialize a colored console logger with optional custom logging level.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>str</code> <p>Specify a string value of the logging level. This field is case-insensitive and will default to 'INFO' if not provided.</p> <code>None</code> <p>Example:</p> <p>Initialize Colored console logger with a custom logging level <pre><code>from ibx_sdk.logger.ibx_logger import init_console_logger\n\n# Initialize a console logger with a custom logging level\ninit_console_logger(level='DEBUG')\n</code></pre></p> Source code in <code>src/ibx_sdk/logger/ibx_logger.py</code> <pre><code>def init_console_logger(level: Optional[str] = None):\n    \"\"\"\n    Initialize a colored console logger with optional custom logging level.\n\n    Args:\n        level (str, optional): Specify a string value of the logging level.\n            This field is case-insensitive and will default to 'INFO' if not provided.\n\n    Example:\n\n    **Initialize Colored console logger with a custom logging level**\n    ```python\n    from ibx_sdk.logger.ibx_logger import init_console_logger\n\n    # Initialize a console logger with a custom logging level\n    init_console_logger(level='DEBUG')\n    ```\n\n    \"\"\"\n    if level:\n        log_level = log_levels.get(level.upper(), logging.INFO)\n    else:\n        log_level = logging.INFO\n    coloredlogs.DEFAULT_FIELD_STYLES[\"filename\"] = dict(color=\"blue\")\n    log_fmt = \"%(asctime)s [%(filename)s:%(lineno)d] %(levelname)s %(message)s\"\n    root_logger = logging.getLogger()\n    root_logger.setLevel(log_level)\n    coloredlogs.install(logger=root_logger, level=log_level, fmt=log_fmt)\n    return root_logger\n</code></pre>"},{"location":"modules/logger/#ibx_sdk.logger.ibx_logger.init_logger","title":"<code>init_logger(logfile_name, logfile_mode='w', console_log=None, max_size=None, num_logs=None, level=None)</code>","text":"<p>Create and return a custom file/console logger.</p> <p>Parameters:</p> Name Type Description Default <code>logfile_name</code> <code>str</code> <p>The name of the log file.</p> required <code>logfile_mode</code> <code>str</code> <p>Specify the mode for the log file. 'a' for append or 'w' for write mode for basic file logging.</p> <code>'w'</code> <code>console_log</code> <code>bool</code> <p>If True, create a colored console log.</p> <code>None</code> <code>max_size</code> <code>int</code> <p>Specify the maximum size for the log file (in bytes) if you want to use a rotating log file handler instead of a standard log file handler.</p> <code>None</code> <code>num_logs</code> <code>int</code> <p>Specify the number of log files to keep if you want to use a rotating log file handler instead of a standard log file handler.</p> <code>None</code> <code>level</code> <code>str</code> <p>Specify a string value for the logging level. This field is case-insensitive and will default to 'INFO' if not provided.</p> <code>None</code> <p>Returns:</p> Type Description <code>Logger</code> <p>logging.Logger: The root logger.</p> <p>Example:</p> <p>Basic FileHandler <pre><code>from ibx_sdk.logger.ibx_logger import init_logger\n\n# Initialize a basic logger to a file using write mode\nlog = init_logger('logs/mylog.log', 'w')\n</code></pre></p> <p>Advanced RotatingFileHandler <pre><code>from ibx_sdk.logger.ibx_logger import init_logger\n\n# Initialize rotating file logging\n\nlog = init_logger(\n    logfile_name='logs/mylog.log',\n    max_size=1000000,\n    num_logs=10\n)\n</code></pre></p> Source code in <code>src/ibx_sdk/logger/ibx_logger.py</code> <pre><code>def init_logger(\n    logfile_name: str,\n    logfile_mode: Optional[str] = \"w\",\n    console_log: Optional[bool] = None,\n    max_size: Optional[int] = None,\n    num_logs: Optional[int] = None,\n    level: Optional[str] = None,\n) -&gt; logging.Logger:\n    \"\"\"\n    Create and return a custom file/console logger.\n\n    Args:\n        logfile_name (str): The name of the log file.\n        logfile_mode (str, optional): Specify the mode for the log file. 'a' for\n            append or 'w' for write mode for basic file logging.\n        console_log (bool, optional): If True, create a colored console log.\n        max_size (int, optional): Specify the maximum size for the log file (in\n            bytes) if you want to use a rotating log file handler instead of a\n            standard log file handler.\n        num_logs (int, optional): Specify the number of log files to keep if you\n            want to use a rotating log file handler instead of a standard log\n            file handler.\n        level (str, optional): Specify a string value for the logging level. This\n            field is case-insensitive and will default to 'INFO' if not provided.\n\n    Returns:\n        logging.Logger: The root logger.\n\n    Example:\n\n    **Basic FileHandler**\n    ```python\n    from ibx_sdk.logger.ibx_logger import init_logger\n\n    # Initialize a basic logger to a file using write mode\n    log = init_logger('logs/mylog.log', 'w')\n    ```\n\n    **Advanced RotatingFileHandler**\n    ```python\n    from ibx_sdk.logger.ibx_logger import init_logger\n\n    # Initialize rotating file logging\n\n    log = init_logger(\n        logfile_name='logs/mylog.log',\n        max_size=1000000,\n        num_logs=10\n    )\n    ```\n    \"\"\"\n    if level:\n        log_level = log_levels.get(level.upper(), logging.INFO)\n    else:\n        log_level = logging.INFO\n    log_fmt = \"%(asctime)s [%(filename)s:%(lineno)d] %(levelname)s %(message)s\"\n    root_logger = logging.getLogger()\n    root_logger.setLevel(log_level)\n\n    # feature - logfile path\n    if os.getenv(\"IBX_LOGDIR\"):\n        if not os.path.exists(os.getenv(\"IBX_LOGDIR\")):\n            try:\n                os.makedirs(os.getenv(\"IBX_LOGDIR\"))\n            except FileExistsError as err:\n                logging.warning(err)\n            except OSError as err:\n                logging.warning(err)\n        logfile_name = os.path.join(os.getenv(\"IBX_LOGDIR\"), logfile_name)\n\n    if num_logs and max_size:\n        lfh = RotatingFileHandler(\n            filename=logfile_name, maxBytes=max_size, backupCount=num_logs\n        )\n    else:\n        lfh = logging.FileHandler(\n            filename=logfile_name,\n            mode=logfile_mode,\n        )\n    lfh.setFormatter(logging.Formatter(log_fmt))\n    lfh.setLevel(log_level)\n    root_logger.addHandler(lfh)\n\n    if console_log:\n        init_console_logger(level)\n\n    root_logger.debug(\"using logfile_name = %s\", logfile_name)\n    return root_logger\n</code></pre>"},{"location":"modules/logger/#ibx_sdk.logger.ibx_logger.set_log_level","title":"<code>set_log_level(level, handler_type='both')</code>","text":"<p>Set the logging level for the root logger and specific handlers.</p> <p>Parameters:</p> Name Type Description Default <code>level</code> <code>str</code> <p>The desired logging level, e.g., 'DEBUG', 'INFO', 'WARNING'. This field is case-insensitive.</p> required <code>handler_type</code> <code>str</code> <p>Specify the type of handlers to set the logging level for. Can be 'both' (default), 'console', or 'file'.</p> <code>'both'</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> <p>Example:</p> <p>Set the logging level for both console and file handlers to 'DEBUG'</p> <pre><code>from your_module import set_log_level\n\n# Set the logging level for both console and file handlers\nset_log_level(level='DEBUG')\n\n# or more explicitly using:\nset_log_level(level='DEBUG', handler_type='both')\n\n# Set the logging level for console handlers only to 'INFO'\nset_log_level(level='INFO', handler_type='console')\n</code></pre> Source code in <code>src/ibx_sdk/logger/ibx_logger.py</code> <pre><code>def set_log_level(level: str, handler_type: str = \"both\") -&gt; None:\n    \"\"\"\n    Set the logging level for the root logger and specific handlers.\n\n    Args:\n        level (str): The desired logging level, e.g., 'DEBUG', 'INFO', 'WARNING'.\n            This field is case-insensitive.\n        handler_type (str, optional): Specify the type of handlers to set the\n            logging level for. Can be 'both' (default), 'console', or 'file'.\n\n    Returns:\n        None\n\n    Example:\n\n    **Set the logging level for both console and file handlers to 'DEBUG'**\n\n    ```python\n    from your_module import set_log_level\n\n    # Set the logging level for both console and file handlers\n    set_log_level(level='DEBUG')\n\n    # or more explicitly using:\n    set_log_level(level='DEBUG', handler_type='both')\n\n    # Set the logging level for console handlers only to 'INFO'\n    set_log_level(level='INFO', handler_type='console')\n    ```\n\n    \"\"\"\n    log_level = log_levels.get(level.upper(), logging.INFO)\n    root_logger = logging.getLogger()\n    if handler_type == \"both\":\n        root_logger.setLevel(log_level)\n    for handle in root_logger.handlers:\n        if isinstance(handle, coloredlogs.StandardErrorHandler) and handler_type in [\n            \"both\",\n            \"console\",\n        ]:\n            coloredlogs.set_level(log_level)\n        elif (\n            isinstance(handle, logging.FileHandler)\n            or isinstance(handle, logging.handlers.RotatingFileHandler)\n            and handler_type in [\"both\", \"file\"]\n        ):\n            handle.setLevel(log_level)\n</code></pre>"},{"location":"modules/util/","title":"Utility Functions","text":"<p>Copyright 2023 Infoblox</p> <p>Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at</p> <pre><code>https://www.apache.org/licenses/LICENSE-2.0\n</code></pre> <p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>"},{"location":"modules/util/#ibx_sdk.util.util.csv_filtered_header","title":"<code>csv_filtered_header(row, col_filter=None)</code>","text":"<p>fetches csv required fields for header w/ any other(s) in filter list</p> <p>@param row: csv header row with fieldnames @param col_filter: list of other columns to filter on @return header_object: dictionary of column and index in the header row</p> Source code in <code>src/ibx_sdk/util/util.py</code> <pre><code>def csv_filtered_header(row: dict, col_filter: list = None) -&gt; dict:\n    \"\"\"\n    fetches csv required fields for header w/ any other(s) in filter list\n\n    @param row: csv header row with fieldnames\n    @param col_filter: list of other columns to filter on\n    @return header_object: dictionary of column and index in the header row\n    \"\"\"\n    header_object = {}\n    items = list(row.keys())\n    for col in row:\n        if \"header-\" in col:\n            idx = items.index(col)\n            header_object[col] = idx\n        elif col.endswith(\"*\"):\n            idx = items.index(col)\n            header_object[col] = idx\n        elif col_filter and col in col_filter:\n            idx = items.index(col)\n            header_object[col] = idx\n    logging.debug(header_object)\n    return header_object\n</code></pre>"},{"location":"modules/util/#ibx_sdk.util.util.extract_filename_from_url","title":"<code>extract_filename_from_url(url)</code>","text":"<p>The function extract_filename_from_url retrieves the name of the CSV file from a given URL.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>An Infoblox download URL for CSV export.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The name of the file that would be downloaded from the specified URL.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>An exception is raised if the URL cannot be parsed.</p> Logging <p>This function logs debug messages as it parses the URL, and an error message if an exception was raised while parsing.</p> Usage <p>Use this function to retrieve the name of a file from an Infoblox download URL:</p> <p>file_name = extract_filename_from_url('https://my-infoblox-instance/export.csv')</p> Source code in <code>src/ibx_sdk/util/util.py</code> <pre><code>def extract_filename_from_url(url) -&gt; str:\n    \"\"\"\n    The function extract_filename_from_url retrieves the name of the CSV file from a given URL.\n\n    Args:\n        url (str): An Infoblox download URL for CSV export.\n\n    Returns:\n        str: The name of the file that would be downloaded from the specified URL.\n\n    Raises:\n        Exception: An exception is raised if the URL cannot be parsed.\n\n    Logging:\n        This function logs debug messages as it parses the URL, and an error message if an exception\n        was raised while parsing.\n\n    Usage:\n        Use this function to retrieve the name of a file from an Infoblox download URL:\n        &gt;&gt;&gt; file_name = extract_filename_from_url('https://my-infoblox-instance/export.csv')\n    \"\"\"\n\n    logging.debug(\"parsing url: %s\", url)\n    try:\n        obj = urlparse(url)\n    except Exception as err:\n        logging.error(err)\n        raise\n    logging.debug(pprint.pformat(obj))\n    parts = obj.path.split(\"/\")\n    filename = str(parts[-1]).lower()\n    logging.debug(\"parsed filename %s\", filename)\n\n    return filename\n</code></pre>"},{"location":"modules/util/#ibx_sdk.util.util.generate_from_includes","title":"<code>generate_from_includes(chroot, filepath)</code>","text":"<p>The function generate_from_includes generates a configuration file from include(s) directives found in another configuration file.</p> <p>Parameters:</p> Name Type Description Default <code>chroot</code> <code>str</code> <p>The path to the chroot environment where the config file to process exists.</p> required <code>filepath</code> <code>str</code> <p>Path to the initial config file to process. The path is relative to             chroot if                 it starts with '/'.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A single string containing the full contents of the config file. This includes data</p> <code>str</code> <p>from the initial config file and all files included with include directives. If the file specified in the filepath parameter does not exist, an empty string is returned.</p> Logging <p>This function logs informational messages indicating the files it's processing and any 'include' directives it encounters. An error message is logged if it attempts to process a file that doesn't exist.</p> Usage <p>Use this function to generate a full config file from one that includes other files with include directives:</p> <p>full_config = generate_from_includes('/path/to/chroot', '/path/to/my_config')</p> Source code in <code>src/ibx_sdk/util/util.py</code> <pre><code>def generate_from_includes(chroot: str, filepath: str) -&gt; str:\n    \"\"\"\n    The function generate_from_includes generates a configuration file from include(s) directives\n    found in another configuration file.\n\n    Args:\n        chroot (str): The path to the chroot environment where the config file to process exists.\n        filepath (str): Path to the initial config file to process. The path is relative to\n                        chroot if\n                            it starts with '/'.\n\n    Returns:\n        str: A single string containing the full contents of the config file. This includes data\n        from\n            the initial config file and all files included with include directives. If the file\n            specified\n            in the filepath parameter does not exist, an empty string is returned.\n\n    Logging:\n        This function logs informational messages indicating the files it's processing and any\n        'include'\n        directives it encounters. An error message is logged if it attempts to process a file\n        that doesn't exist.\n\n    Usage:\n        Use this function to generate a full config file from one that includes other files with\n        include directives:\n        &gt;&gt;&gt; full_config = generate_from_includes('/path/to/chroot', '/path/to/my_config')\n    \"\"\"\n\n    if filepath.startswith(\"/\"):\n        filepath = filepath.lstrip(\"/\")\n    logging.info(\"processing file %s\", f\"{chroot}{filepath}\")\n    data = \"\"\n    if os.path.exists(os.path.join(chroot, filepath)):\n        with open(os.path.join(chroot, filepath), \"r\", encoding=\"utf8\") as file:\n            for line in file:\n                if line.startswith(\"include \"):\n                    logging.debug(line.strip())\n                    _, include_file, _ = line.split('\"', 2)\n                    logging.info(\"processing include file %s\", include_file)\n                    contents = _get_include_data(chroot, include_file)\n                    if contents:\n                        data += contents\n                else:\n                    data += line\n    else:\n        logging.error(\"file %s does not exist!\", os.path.join(chroot, filepath))\n    return data\n</code></pre>"},{"location":"modules/util/#ibx_sdk.util.util.get_csv_header","title":"<code>get_csv_header(csvfile)</code>","text":"<pre><code>The function get_csv_header retrieves the header from a CSV file.\n\nArgs:\n    csvfile (io.TextIOWrapper): A file object for the CSV file from which to retrieve the\n    header.\n\nReturns:\n    list: A list of strings where each string is a column name from the CSV file's header row.\n        If the CSV file has no header row, an empty list is returned.\n\nUsage:\n    Use this function to get the header from a CSV file:\n    &gt;&gt;&gt; with open('/path/to/my_file.csv', 'r') as csv_file:\n    ...     # noinspection PyTypeChecker\n</code></pre> <p>header = get_csv_header(csv_file)         ...     print(header)</p> Source code in <code>src/ibx_sdk/util/util.py</code> <pre><code>def get_csv_header(csvfile: io.TextIOWrapper) -&gt; list:\n    \"\"\"\n        The function get_csv_header retrieves the header from a CSV file.\n\n        Args:\n            csvfile (io.TextIOWrapper): A file object for the CSV file from which to retrieve the\n            header.\n\n        Returns:\n            list: A list of strings where each string is a column name from the CSV file's header row.\n                If the CSV file has no header row, an empty list is returned.\n\n        Usage:\n            Use this function to get the header from a CSV file:\n            &gt;&gt;&gt; with open('/path/to/my_file.csv', 'r') as csv_file:\n            ...     # noinspection PyTypeChecker\n    header = get_csv_header(csv_file)\n            ...     print(header)\n    \"\"\"\n    csvfile.seek(0)\n    sample = csvfile.read(1024)\n    dialect = csv.Sniffer().sniff(sample)\n    cols = []\n    if csv.Sniffer().has_header(sample):\n        csvfile.seek(0)\n        myreader = csv.reader(csvfile, dialect)\n        cols = next(myreader)\n    return cols\n</code></pre>"},{"location":"modules/util/#ibx_sdk.util.util.ibx_csv_file_split","title":"<code>ibx_csv_file_split(filename, output_path='.')</code>","text":"<p>The function ibx_csv_file_split splits a globally exported CSV file into separate CSV files based on the CSV object type(s).</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the source CSV file to be split.</p> required <code>output_path</code> <code>str</code> <p>The directory where the output CSV files will be written. If the directory does not exist, it will be created. Defaults to the current directory.</p> <code>'.'</code> <p>Raises:</p> Type Description <code>Exception</code> <p>An exception is raised if the output directory cannot be created.</p> Logging <p>This function logs warning messages when a CSV object type has no associated objects in the source CSV. It also logs informational messages when it creates output CSV files.</p> Usage <p>Use this function to split a <code>Infoblox</code> exported CSV file into separate CSV files for each CSV object type:</p> <p>ibx_csv_file_split('/path/to/my_exported_csv_file', '/path/to/output_directory')</p> Source code in <code>src/ibx_sdk/util/util.py</code> <pre><code>def ibx_csv_file_split(filename: str, output_path: str = \".\"):\n    \"\"\"\n    The function ibx_csv_file_split splits a globally exported CSV file into separate CSV files\n    based on the CSV object type(s).\n\n    Args:\n        filename (str): The name of the source CSV file to be split.\n        output_path (str, optional): The directory where the output CSV files will be written.\n            If the directory does not exist, it will be created. Defaults to the current directory.\n\n    Raises:\n        Exception: An exception is raised if the output directory cannot be created.\n\n    Logging:\n        This function logs warning messages when a CSV object type has no associated objects in\n        the source CSV.\n        It also logs informational messages when it creates output CSV files.\n\n    Usage:\n        Use this function to split a `Infoblox` exported CSV file into separate CSV files for\n        each CSV object type:\n        &gt;&gt;&gt; ibx_csv_file_split('/path/to/my_exported_csv_file', '/path/to/output_directory')\n    \"\"\"\n\n    if not os.path.exists(output_path):\n        logging.warning(\"output path %s does not exist, creating...\", output_path)\n        try:\n            os.makedirs(output_path, exist_ok=True)\n        except Exception as err:\n            logging.error(err)\n            raise\n\n    # build the struct using the csv object type as the key\n    csv_objects = {}\n    with open(filename, \"r\", encoding=\"utf8\") as handle:\n        myreader = csv.reader(handle)\n        for row in myreader:\n            if row[0].lower().startswith(\"header-\"):\n                obj_type = row[0].lower().replace(\"header-\", \"\")\n                csv_output_file = f\"{obj_type}.csv\"\n                csv_output_file_path = os.path.join(output_path, csv_output_file)\n                csv_objects[obj_type] = {}\n                csv_objects[obj_type][\"filename\"] = csv_output_file\n                csv_objects[obj_type][\"filepath\"] = csv_output_file_path\n                csv_objects[obj_type][\"data\"] = [row]\n            else:\n                obj_type = row[0].lower()\n                csv_objects[obj_type][\"data\"].append(row)\n\n    # output the struct\n    for obj_type, obj_data in csv_objects.items():\n        num_of_objects = len(obj_data[\"data\"])\n        if num_of_objects == 1:\n            logging.warning(\n                \"skipping creating output file %s, no %s objects\",\n                obj_data[\"filename\"],\n                obj_type,\n            )\n        else:\n            logging.info(\n                \"creating output file %s with %s %s objects\",\n                obj_data[\"filename\"],\n                num_of_objects,\n                obj_type,\n            )\n            with open(obj_data[\"filepath\"], \"w\", encoding=\"utf8\") as fh_out:\n                mywriter = csv.writer(fh_out)\n                for row in obj_data[\"data\"]:\n                    mywriter.writerow(row)\n                fh_out.close()\n</code></pre>"},{"location":"modules/util/#ibx_sdk.util.util.named_checkconf","title":"<code>named_checkconf(chroot_path, conf_path)</code>","text":"<p>perform named-checkconf and re-write a canonicalized copy of the named.conf file</p> <p>Parameters:</p> Name Type Description Default <code>chroot_path</code> <code>str</code> <p>Description of the first argument <code>chroot_path</code>.</p> required <code>conf_path</code> <code>str</code> <p>Description of the second argument <code>conf_path</code>.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Example <p>Here you can provide an example of how to use your function.</p> <p>named_checkconf(\"/path/to/chroot\", \"/path/to/conf\")</p> Source code in <code>src/ibx_sdk/util/util.py</code> <pre><code>def named_checkconf(chroot_path: str, conf_path: str) -&gt; None:\n    \"\"\"\n    perform named-checkconf and re-write a canonicalized copy of the named.conf file\n\n    Args:\n        chroot_path (str): Description of the first argument `chroot_path`.\n        conf_path (str): Description of the second argument `conf_path`.\n\n    Returns:\n        None\n\n    Example:\n        Here you can provide an example of how to use your function.\n        &gt;&gt;&gt; named_checkconf(\"/path/to/chroot\", \"/path/to/conf\")\n    \"\"\"\n\n    logging.info(\"parsing %s conf file\", conf_path)\n\n    if not os.path.exists(f\"{chroot_path}/{conf_path}\"):\n        logging.error(\"%s does not exist\", f\"{chroot_path}/{conf_path}\")\n        raise FileNotFoundError\n    command = f\"sudo named-checkconf -p -t {chroot_path} {conf_path} &gt; name.conf\"\n    logging.debug(command)\n    res = subprocess.run(\n        [\"sudo\", \"named-checkconf\", \"-p\", \"-t\", chroot_path, conf_path],\n        capture_output=True,\n        text=True,\n        check=True,\n    )\n    if res.stdout:\n        with open(\"named.conf\", \"w\", encoding=\"utf8\") as file:\n            file.write(res.stdout)\n    if res.stderr:\n        logging.error(res.stderr)\n</code></pre>"},{"location":"modules/util/#ibx_sdk.util.util.named_compilezone","title":"<code>named_compilezone(zone_name, zone_file, output_file, input_format='text')</code>","text":"<p>The function named_compilezone performs the named-compilezone command to canonicalize and rewrite a specified DNS zone file, checking for errors in the file during the process.</p> <p>Parameters:</p> Name Type Description Default <code>zone_name</code> <code>str</code> <p>The name of the DNS zone being processed.</p> required <code>zone_file</code> <code>str</code> <p>The path to the file containing the DNS zone information to be              read/processed.</p> required <code>output_file</code> <code>str</code> <p>The path where the canonicalized zone file will be written to.</p> required <code>input_format</code> <code>str</code> <p>The format in which the zone information is currently                           presented in the zone file.                           This should be either 'text' or 'raw'. Defaults to 'text'.</p> <code>'text'</code> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of strings, each string being a line from the output of the named-compilezone command that indicates an error which prevented the DNS zone from being loaded. If there are no such errors, an empty list is returned.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>input_format</code> is neither 'text' or 'raw'</p> Usage <p>Call this function to check for, log, and return errors in a DNS zone file as it is being processed:</p> <p>errors = named_compilezone('my_zone', '/path/to/my_zone_file', '/path/to/output_file') if errors: ...     print('Errors found during zone processing.') ...     for error in errors: ...         print(error)</p> Source code in <code>src/ibx_sdk/util/util.py</code> <pre><code>def named_compilezone(\n    zone_name: str, zone_file: str, output_file: str, input_format: str = \"text\"\n) -&gt; list:\n    \"\"\"\n    The function named_compilezone performs the named-compilezone command to canonicalize and\n    rewrite a specified DNS zone file, checking for errors in the file during the process.\n\n    Args:\n        zone_name (str): The name of the DNS zone being processed.\n        zone_file (str): The path to the file containing the DNS zone information to be\n                         read/processed.\n        output_file (str): The path where the canonicalized zone file will be written to.\n        input_format (str, optional): The format in which the zone information is currently\n                                      presented in the zone file.\n                                      This should be either 'text' or 'raw'. Defaults to 'text'.\n\n    Returns:\n        list: A list of strings, each string being a line from the output of the named-compilezone\n            command that indicates an error which prevented the DNS zone from being loaded.\n            If there are no such errors, an empty list is returned.\n\n    Raises:\n        ValueError: If `input_format` is neither 'text' or 'raw'\n\n    Usage:\n        Call this function to check for, log, and return errors in a DNS zone file as it is being\n        processed:\n        &gt;&gt;&gt; errors = named_compilezone('my_zone', '/path/to/my_zone_file', '/path/to/output_file')\n        &gt;&gt;&gt; if errors:\n        ...     print('Errors found during zone processing.')\n        ...     for error in errors:\n        ...         print(error)\n    \"\"\"\n\n    if input_format not in [\"raw\", \"text\"]:\n        raise ValueError('specify one of \"text\" or \"raw\" value')\n    command = (\n        f\"named-compilezone -k ignore -i none -f {input_format} -o {output_file} \"\n        f\"{zone_name} {zone_file}\"\n    )\n    logging.debug(command)\n    try:\n        subprocess.run(\n            [\n                \"named-compilezone\",\n                \"-i\",\n                \"none\",\n                \"-k\",\n                \"ignore\",\n                \"-m\",\n                \"ignore\",\n                \"-n\",\n                \"ignore\",\n                \"-r\",\n                \"ignore\",\n                \"-s\",\n                \"full\",\n                \"-f\",\n                input_format,\n                \"-o\",\n                output_file,\n                zone_name,\n                zone_file,\n            ],\n            check=True,\n            capture_output=True,\n            text=True,\n        )\n    except subprocess.CalledProcessError as err:\n        if int(err.returncode) &gt; 0 and \"not loaded due to errors.\" in err.stdout:\n            logging.error(\"err_code: %s\", err.returncode)\n            for line in err.stdout.split(\"\\n\"):\n                if line:\n                    logging.error(line)\n            return _parse_named_checkzone_log(err.stdout)\n\n        for line in err.stdout.split(\"\\n\"):\n            if line:\n                logging.debug(line)\n            return []\n    return []\n</code></pre>"},{"location":"modules/util/#ibx_sdk.util.util.remove_lines_from_file","title":"<code>remove_lines_from_file(file_path, lines_to_remove, output_path=None)</code>","text":"<p>The function remove_lines_from_file removes specific lines from a file.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The fully qualified path to the file from which lines are to be removed.</p> required <code>lines_to_remove</code> <code>list</code> <p>A list of integers, with each integer being a line                     number (1-indexed) of the line to be removed from the file.</p> required <code>output_path</code> <code>str</code> <p>Path to the output file. If provided, the function will                          write result to this file.                          If not provided, the function will overwrite the original                          file. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Logging <p>This function logs warning messages for each line that it removes from the file. It also logs an info message once the file has been successfully rewritten.</p> Usage <p>Use this function to remove specific lines from a file:</p> <p>remove_lines_from_file('/path/to/my_file', [2, 3]) This will remove the 2nd and 3rd lines from the file located at /path/to/my_file.</p> <p>To write the result to a different file, specify the output_path argument:</p> <p>remove_lines_from_file('/path/to/my_file', [2, 3], '/path/to/output_file') This will remove the 2nd and 3rd lines from the file located at /path/to/my_file and write the result to a file located at /path/to/output_file.</p> Source code in <code>src/ibx_sdk/util/util.py</code> <pre><code>def remove_lines_from_file(\n    file_path: str, lines_to_remove: list, output_path: str = None\n) -&gt; None:\n    \"\"\"\n    The function remove_lines_from_file removes specific lines from a file.\n\n    Args:\n        file_path (str): The fully qualified path to the file from which lines are to be removed.\n        lines_to_remove (list): A list of integers, with each integer being a line\n                                number (1-indexed) of the line to be removed from the file.\n        output_path (str, optional): Path to the output file. If provided, the function will\n                                     write result to this file.\n                                     If not provided, the function will overwrite the original\n                                     file. Defaults to None.\n\n    Returns:\n        None\n\n    Logging:\n        This function logs warning messages for each line that it removes from the file.\n        It also logs an info message once the file has been successfully rewritten.\n\n    Usage:\n        Use this function to remove specific lines from a file:\n        &gt;&gt;&gt; remove_lines_from_file('/path/to/my_file', [2, 3])\n        This will remove the 2nd and 3rd lines from the file located at /path/to/my_file.\n\n        To write the result to a different file, specify the output_path argument:\n        &gt;&gt;&gt; remove_lines_from_file('/path/to/my_file', [2, 3], '/path/to/output_file')\n        This will remove the 2nd and 3rd lines from the file located at /path/to/my_file\n        and write the result to a file located at /path/to/output_file.\n    \"\"\"\n\n    if not output_path:\n        output_path = file_path\n    logging.warning(\"file: %s lines to remove: %s\", file_path, lines_to_remove)\n    with open(file_path, \"r\", encoding=\"utf8\") as fin:\n        lines = fin.readlines()\n        ptr = 1\n        with open(output_path, \"w\", encoding=\"utf8\") as fout:\n            for line in lines:\n                if ptr not in lines_to_remove:\n                    fout.write(line)\n                else:\n                    logging.warning(\n                        \"file: %s - removing line: %s\", output_path, line.strip()\n                    )\n                ptr += 1\n            logging.info(\"file %s rewritten\", output_path)\n</code></pre>"},{"location":"user_guide/","title":"Introduction","text":"<p>The Infoblox <code>ibx-sdk</code> is a library and SDK designed to assist users in developing efficient automation scripts for the Infoblox NIOS Web API (WAPI). The SDK offers a range of tools for effective API interaction, including the following:</p> <ol> <li>The <code>Gift</code> wrapper class - The <code>Gift</code> class is a wrapper around the Python <code>requests</code>, which    in turn makes it easier to access the Infoblox Web API module.</li> <li>Detailed usage and example documentation</li> <li>Sample operations scripts</li> </ol> <p>Note</p> <p>What is <code>Gift</code>??</p> <p><code>Gift</code> is an object-oriented Python class which is a wrapper to the Python <code>requests</code> package.  It specifically builds and extends the <code>requests.session</code> module. Why the name \"Gift\"? We  named it <code>Gift</code> because of the fact it's a wrapper. Get it?? We'd like to think it will be the  \"Gift\" that keeps on giving... Other names considered were:</p> <ul> <li>Cellophane - for its transparent, light-weight wrapping prowess!</li> <li>Bacon - because bacon wrapped anything is good!</li> </ul> <p>We hope you enjoy!</p> <p>The <code>Gift()</code> Python class is a wrapper for <code>requests.session</code>, supporting the same HTTP Request methods that are supported by the NIOS WAPI. See the table below:</p> WAPI Method Gift Request Method Description GET Gift.get() An HTTP GET is used to read a single object or fetch multiple objects POST Gift.post() The POST method is used to create a new object PUT Gift.put() The PUT method is used to update an existing object. DELETE Gift.delete() The DELETE method is used to remove an existing object. <p>Note</p> <p>There is also a convenience method that has been added to the Gift() class for fetcing a single object. The <code>Gift.getone()</code> method expects to fetch a single record and returns the record's  <code>_ref</code>. It raises an exception if it fails to return any data or if it finds &gt; 1 record.</p>"},{"location":"user_guide/#installing-ibx-sdk","title":"Installing <code>ibx-sdk</code>","text":"<pre><code>pip install ibx-sdk\n</code></pre>"},{"location":"user_guide/#initializing-the-wapi-class","title":"Initializing the WAPI class","text":"<p>First, you have to import it into your scripts:</p> <pre><code>from ibx_sdk.nios.gift import Gift\n</code></pre> <p>Once imported you can instantiate the class as follows:</p> <pre><code>from ibx_sdk.nios.gift import Gift\n\nwapi = Gift()\n</code></pre> <p>Tip</p> <p>We always recommend installing the <code>ibx-sdk</code> into a Python Virtual Environment to avoid polluting your global Python module(s) environment.</p> <p>To create a Python virtual environment, perform this sequence of steps:</p> <pre><code>cd ~/workspace\n\nmkdir myproject\ncd myproject\npython3 -m venv .venv\nsource .vent/bin/activate\npip install -U pip setuptools\n</code></pre> <p>The above code was performed on a Mac, it leverages a <code>workspace</code> folder that would have all our project(s) and code. We  create a new project called <code>myproject</code> and \"install\" a virtual environment in that folder with <code>python3</code>. We sourced  the environment on line #6. Last we update the <code>pip</code> and <code>setuptools</code> modules.</p> <p>Warning</p> <p>Always source your Python virutal environment of your project or you may end up polluting your own module space. </p> <p>Remember to always source your environment prior to working on your next project:</p> <pre><code>source .venv/bin/activate\n</code></pre> <p>You can deactivate when you are done using/modifying the project code:</p> <pre><code>deactivate\n</code></pre>"},{"location":"user_guide/connection/","title":"Connecting to WAPI","text":"<p>To establish a connection to your NIOS Grid via the WAPI, you'll need to instantiate an instance of the <code>Gift</code> class  in the <code>ibx-sdk</code>. The <code>Gift</code> class, requires you have the following information:</p> <ul> <li>Grid Manager hostname or IP Address</li> <li>NIOS Administrative User credentials <code>username</code> and <code>password</code></li> <li>(optionally) the NIOS version <code>wapi_ver</code></li> </ul> <p>Scripts can be fashioned like the examples provided in this SDK to obtain these properties as command line arguments. In addition, you could use a <code>.env</code> file or roll your own <code>config.yaml</code> file. The last thing you want to do is hard-code  these in your scripts which would be very insecure. The scripts contained in this SDK use the Python <code>@click</code> module which provides convenient CLI argument parsing and validation.</p> <p>There are three (4) ways of instantiating the <code>Gift</code> class:</p> <ol> <li>positional arguments</li> <li>named arguments</li> <li>instance variables</li> <li>dictionary of properties or key-value pairs</li> </ol>"},{"location":"user_guide/connection/#positional-arguments","title":"Positional Arguments","text":"<p>To establish a connection to a NIOS Grid Manager using positional arguments, use the following:</p> <pre><code>from ibx_sdk.nios.gift import Gift\n\ngrid_mgr = 'infoblox.localdomain'\nwapi_ver = '2.11'\nssl_verify = False\nusername = 'admin'\npassword = 'infoblox'\n\nwapi = Gift(grid_mgr, wapi_ver, ssl_verify)\n\nwapi.connect(username, password)\n</code></pre> <p>Warning</p> <p>While this works and is acceptable, we do not recommend using positional arguments. Instead, leverage named arguments to remove any abiguity. Positional arguments require specific order - if you get the order wrong the method/call will fail and you may have a hard time figuring out how to resolve it.</p>"},{"location":"user_guide/connection/#named-arguments","title":"Named Arguments","text":"<p>Instead of positional arguments it's recommended you use named args and parameters as shown below:</p> <pre><code>from ibx_sdk.nios.gift import Gift\n\nwapi = Gift(grid_mgr='infoblox.localdomain', wapi_ver='2.11', ssl_verify='/path/to/certfile')\nwapi.connect(username='admin', password='infoblox')\n</code></pre>"},{"location":"user_guide/connection/#instance-variables","title":"Instance Variables","text":"<p>In the next example, we establish our connection to the NIOS Grid Manager by instantiating the <code>Gift</code> class, and building it up using the <code>Gift</code> class properties.</p> <pre><code>from ibx_sdk.nios.gift import Gift\n\nwapi = Gift()\nwapi.grid_mgr = 'infoblox.localdomain'\nwapi.wapi_ver = '2.11'\nwapi.ssl_verify = '/path/to/certfile'\n\nusername = 'admin'\npassword = 'infoblox'\n\nwapi.connect(username, password)\n</code></pre> <p>Tip</p> <p>By instantiating an empty instance of the <code>Gift</code> class, you can make the <code>wapi</code> instance variable global instead of having to pass it around in your scripts to other functions and methods. See Below.</p> <pre><code>from ibx_sdk.nios.gift import Gift\n\nwapi = Gift()\n\n\ndef get_grid():\n    # the wapi instance is visible in the method\n    res = wapi.get(f'{wapi.url}/grid')\n\n\ndef main():\n    wapi.grid_mgr = 'infoblox.localdomain'\n    wapi.wapi_ver = '2.11'\n    wapi.ssl_verify = '/path/to/certfile'\n\n    wapi.connect(username='admin', password='infoblox')\n    get_grid()\n</code></pre> <p>line 3 - We're instantiating the <code>Gift</code> class without any attributes set on the instance globally lines 12-14 - we build up the <code>wapi</code> instance line 16 - we establish our connection to the NIOS Grid Manager line 17 - we call a method/function in the code to get the Grid object lines 6-8 - we make a call with the <code>wapi</code> instance. It's visible to the function because we made it global</p> <p>If a <code>Gift</code> instance is not global, you will need to pass it around to any methods and functions which use it. Our previous code would now look more like this:</p> <pre><code>from ibx_sdk.nios.gift import Gift\n\n\ndef get_grid(wapi):\n    # the wapi instance is visible in the method\n    res = wapi.get(f'{wapi.url}/grid')\n\n\ndef main():\n    wapi = Gift()\n    wapi.grid_mgr = 'infoblox.localdomain'\n    wapi.wapi_ver = '2.11'\n    wapi.ssl_verify = '/path/to/certfile'\n\n    wapi.connect(username='admin', password='infoblox')\n    get_grid(wapi)\n</code></pre> <p>Notice how we have to pass the <code>wapi</code> instance to the <code>get_grid</code> function. We MUST do this if the <code>wapi</code> instance is a locally scoped variable instead of a global one.</p>"},{"location":"user_guide/connection/#dictionary-of-properties","title":"Dictionary of properties","text":"<p>In addition to the above, you can instantiate the <code>Gift</code> class using a dictionary and passing that into the constructor shown below:</p> <pre><code>from ibx_sdk.nios.gift import Gift\n\nusername = \"admin\"\npassword = \"infoblox\"\nprops = {\n    \"grid_mgr\": \"infoblox.localdomain\",\n    \"wapi_ver\": \"2.11\",\n    \"verify_ssl\": '/path/to/certfile'\n}\nwapi = Gift(**props)\n\nwapi.connect(username, password)\n</code></pre> <p>This will attempt to use BASIC AUTH to establish a connection with the Grid Manager infoblox.localdomain using the admin user account and password. The <code>wapi.connect()</code> method will return an WapiRequestException if the connection fails. This example shows how to build up the <code>Gift</code> object by passing in a dictionary of key-value pairs.</p>"},{"location":"user_guide/cookbook/","title":"Cookbook / Recipes","text":""},{"location":"user_guide/cookbook/#using-search-modifiers-with-query-params","title":"Using search modifiers with Query Params","text":"<p>The Infoblox NIOS WAPI supports the following Search Modifiers:</p> Modifier Functionality ! Negates the condition, or not x : Makes string matching case insensitive ~ Regular expression search. Expressions are unanchored &lt; Less than or equal &gt; Greater than or equal <p>Note</p> <p>Integers and dates support: !, &lt; and &gt; All other types behave like strings and support: !, ~, and :</p> <pre><code>response = wapi.get(\n    'network',\n    params={'*Building:': 'Data Center'}\n)\n</code></pre> <p>This query is an example of a case-insensitive search for all networks which contain the Extensible Attribute or EA of  Building with a value of data center. Searches for extensible attributes are sent by prefixing the extensible attribute name with an asterisk (*).</p>"},{"location":"user_guide/cookbook/#wapi-inheritance-data-fetching","title":"WAPI Inheritance Data Fetching","text":"<p>show dhcp options inheritance example</p>"},{"location":"user_guide/cookbook/#regex-searches-in-query-params","title":"Regex searches in Query Params","text":"<p>Some object properties allow you to search using regular expressions. The network object for example, allows you to  search using regular expression on the <code>network</code> property. The following is an example of a regular expression search for all networks in the 172.16.0.0/16 space:</p> <pre><code>response = wapi.get(\n    'network',\n    params={'network~': '^172\\.16\\.'}\n)\n</code></pre>"},{"location":"user_guide/cookbook/#updating-eas-on-objects","title":"Updating EAs on objects","text":"<pre><code>ea_data = {\n    'extattrs-': {\n        'attrstring': {},\n        'attrinteger': {}\n    }\n}\nwapi.put(network_ref, json=ea_data)\n</code></pre> <pre><code>ea_data = {\n    'extattrs-': {\n        'attrstring': {'value': 'test string'},\n    }\n}\nwapi.put(network_ref, json=ea_data)\n</code></pre> <pre><code>ea_data = {\n    'extattrs+': {\n        'attrstring': {'value': 'new string'},\n    }\n}\nwapi.put(network_ref, json=ea_data)\n</code></pre> <pre><code>ea_data = {\n    \"extattrs\": {\n        \"attrstring\": {\"value\": \"test string\"},\n        \"attrinteger\": {\"value\": -1},\n        \"attremail\": {\"value\": \"test@test.com\"},\n        \"attrdate\": {\"value\": \"2011-11-23T11:01:00Z\"},\n        \"attrenum\": {\"value\": \"Enum Value\"},\n    }\n}\nwapi.put(network_ref, json=ea_data)\n</code></pre>"},{"location":"user_guide/cookbook/#using-the-request-object","title":"Using the <code>request</code> Object","text":"<p>The <code>request</code> object allows the control of WAPI calls through a single entry point. The object  supports only the POST method and does not support URI arguments. </p> <p>The following code uses the <code>request</code> object to issue two (2) DNS dig requests to different Grid  Members:</p> <pre><code>body = [{\n  \"method\":\"POST\",\n  \"object\":\"grid\",\n  \"args\":{\"_function\":\"query_fqdn_on_member\"},\n  \"data\":{\n    \"name_server\":\"8.8.8.8\",\n    \"fqdn\":\"infoblox.com\",\n    \"record_type\":\"A\",\n    \"member\":\"gm.blox.corp\"\n  }\n},\n{\n  \"method\":\"POST\",\n  \"object\":\"grid\",\n  \"args\":{\"_function\":\"query_fqdn_on_member\"},\n  \"data\":{\n    \"name_server\":\"8.8.8.8\",\n    \"fqdn\":\"infoblox.com\",\n    \"record_type\":\"A\",\n    \"member\":\"gmc.blox.corp\"\n  }\n}]\nresponse = wapi.post(\n    'request',\n    json=body\n)\n</code></pre>"},{"location":"user_guide/delete/","title":"Deleting Objects","text":"<p>When using the WAPI to remove objects from the Grid, often times you will need to obtain a reference or a list of references to objects, and perform a delete call on those object references. Ordinarily it is two (2) calls:</p> <ol> <li> <p>Obtain reference by performing a GET request for the <code>_ref</code> of an object</p> <pre><code>_ref = wapi.getone(&lt;wapi_object&gt;, params, **kwargs)\n</code></pre> </li> <li> <p>Make a DELETE request on the <code>_ref</code> of the object</p> <pre><code>response = wapi.delete(_ref, **kwargs)\n</code></pre> </li> </ol> <p>Tip</p> <p>The Infoblox NIOS WAPI API is fully documented and available online. You can access the API  guide by using the following url path on your Infoblox Grid Manager:</p> <p><code>https://&lt;grid_mgr&gt;/wapidoc</code></p> <p>See the WAPI Guide for details on all objects, properties, functions, and parameters.</p>"},{"location":"user_guide/delete/#delete-network","title":"Delete Network","text":"<ol> <li>Retrieve the object reference from the network</li> <li>Delete the network</li> </ol> <p>Tip</p> <p>The <code>wapi.getone('&lt;wapi_object&gt;', params, **kwargs)</code> method does not return a response object.  It will return an object reference of type string.</p> <p>To fetch the reference for network container 192.168.2.0/24 from the Grid, we start to create our script with the following:</p> <pre><code>import sys\nfrom ibx_sdk.nios.gift import Gift\n\nwapi = Gift(\n    grid_mgr='infoblox.localdomain',\n    wapi_ver='2.12',\n)\n\nwapi.connect(username='admin', password='infoblox')\n\n_ref = wapi.getone(\n    'network',\n    params={'network': '192.168.2.0/23',\n            'network_view': 'default'\n            }\n)\n</code></pre> <p>To delete the network we add the following to our script:</p> <pre><code>response = wapi.delete(_ref)\n</code></pre> <p>Our <code>response</code> above is a Requests response object, and it will contain a number of properties and methods.</p> <p>The ones used most often in working with WAPI data are:</p> property/method Description <code>json()</code> A method returns JSON-encoded object of the result (if the result was JSON encoded) <code>status_code</code> A property representing the HTTP Status Code (200 is OK, 404 is Not Found and so on) <code>text</code> A property which returns the content of the response in unicode <p>We can test the success or failure of the above request by checking for an OK status on the  <code>response</code> object this is done like adding the following to our script:</p> <pre><code>if response.status_code != 200:\n    print(f'We hit a snag {response.text}')\n    sys.exit(1)  # Exit program\n</code></pre>"},{"location":"user_guide/delete/#delete-host-record","title":"Delete Host Record","text":"<ol> <li>Retrieve the object reference from the record:host</li> <li>Delete the host</li> </ol> <p>To fetch the reference for my_router.example.com from the Grid, we start to create our script with the following:</p> <pre><code>import sys\nfrom ibx_sdk.nios.gift import Gift\n\nwapi = Gift(\n    grid_mgr='infoblox.localdomain',\n    wapi_ver='2.12',\n)\n\nwapi.connect(username='admin', password='infoblox')\n\n_ref = wapi.getone(\n    'record:host',\n    params={'name': 'my-router.example.com',\n            'network_view': 'default'\n            }\n)\n</code></pre> <p>To delete the record:host we add the following to our script:</p> <pre><code>response = wapi.delete(_ref)\n</code></pre> <p>We can test the success or failure of the above request by checking for an OK status on the  <code>response</code> object this is done like adding the following to our script:</p> <pre><code>if response.status_code != 200:\n    print(f'We hit a snag {response.text}')\n    sys.exit(1)  # Exit program\n</code></pre>"},{"location":"user_guide/functions/","title":"Calling Functions","text":"<p>Numerous WAPI objects support the ability to call functions on objects. Functions are generally called by issuing a POST request, along with a set of attributes and associated values in a Python Dictionary. The dictionary of properties are sent as a JSON body in the request. Object function calls to WAPI object generally take the form:</p> <pre><code>response = wapi.post('&lt;wapi_object&gt;', json={body}, **kwargs)\n</code></pre> <p>Tip</p> <p>The Infoblox NIOS WAPI API is fully documented and available online. You can access the API guide by using  the following url path on your Infoblox Grid Manager:</p> <p><code>https://&lt;grid_mgr&gt;/wapidoc</code></p> <p>See the WAPI Guide for details on all objects, properties, functions, and parameters.</p>"},{"location":"user_guide/functions/#next-available-network","title":"Next Available Network","text":"<ol> <li>Retrieve the object reference from the network container</li> <li>Fetch 2 available networks from the network container</li> <li>Create the 2 networks received</li> </ol> <p>Tip</p> <p>The <code>wapi.getone('&lt;wapi_object&gt;', params, **kwargs)</code> method does not return a response object.  It will return an object reference of type string.</p> <p>To fetch the reference for network container 192.168.0.0/16 from the Grid, we start to create our script with the following:</p> <pre><code>import sys\nfrom ibx_sdk.nios.gift import Gift\n\nwapi = Gift(\n    grid_mgr='infoblox.localdomain',\n    wapi_ver='2.12',\n)\n\nwapi.connect(username='admin', password='infoblox')\n\n_ref = wapi.getone(\n    'networkcontainer',\n    params={\n        'network': '192.168.0.0/16',\n        'network_view': 'default'\n    }\n)\n</code></pre> <p>To fetch the next available 2 networks within the network container 192.168.0.0/16 we add the following to our script:</p> <pre><code>params = {\n    '_function': 'next_available_network'\n}\n\nbody = {\n    'cidr': 24,\n    'num': 2,\n    'exclude': ['192.168.0.0/24', '192.168.1.0/24']\n}\nresponse = wapi.post(_ref, json=body, params=params)\n</code></pre> <p>Our <code>response</code> above is a Requests response object, and it will contain a number of properties and methods.</p> <p>The ones used most often in working with WAPI data are:</p> property/method Description <code>json()</code> A method returns JSON-encoded object of the result (if the result was JSON encoded) <code>status_code</code> A property representing the HTTP Status Code (200 is OK, 404 is Not Found and so on) <code>text</code> A property which returns the content of the response in unicode <p>We can test the success or failure of the above request by checking for an OK status on the <code>response</code> object this is done like adding the following to our script:</p> <pre><code>if response.status_code != 200:\n    print(f'We hit a snag {response.text}')\n    sys.exit(1)  # Exit program\n</code></pre> <p>To build/create the two next available networks by the function we called, we add the following to our script:</p> <pre><code>networks_dict = response.json()\n\nfor network in networks_dict['networks']:\n    body = {\n        \"network\": network,\n        \"comment\": \"created from next available network routine\"\n    }\n\n    response = wapi.post('network', json=body)\n    if response.status_code == 201:\n        print(f'Yay!!!! Network Created {response.json()}')\n    else:\n        print(f'error: {response.text}')\n</code></pre>"},{"location":"user_guide/functions/#next-available-ip","title":"Next Available IP","text":"<ol> <li>Retrieve the object reference from the network</li> <li>Fetch 10 available networks from the network</li> <li>Create the 10 IP Reservations from the ips received</li> </ol> <p>To fetch the reference for network container 192.168.2.0/24 from the Grid, we start to create our script with the following:</p> <pre><code>import sys\nfrom ibx_sdk.nios.gift import Gift\n\nwapi = Gift(\n    grid_mgr='infoblox.localdomain',\n    wapi_ver='2.12',\n)\n\nwapi.connect(username='admin', password='infoblox')\n\nmy_network = '192.168.2.0/24'\n\n# Retrieve the reference for my_network\n_ref = wapi.getone(\n    'network',\n    params={\n        'network': my_network,\n        'network_view': 'default'\n    }\n)\n</code></pre> <p>To fetch the next 10 available ips within the network 192.168.2.0/24 we add the following to our script:</p> <pre><code>params = {\n    '_function': 'next_available_ip'\n}\n\n# Create the Body of the request\nbody = {\n    'num': 10,\n    'exclude': ['192.168.2.1', '192.168.2.2']\n}\nresponse = wapi.post(_ref, json=body, params=params)\n\nif response.status_code != 200:\n    print(f'We hit a snag {response.text}')\n    sys.exit(1)  # Exit program\n</code></pre> <p>To build/create the 10 fixed addresses received by the function we called, we add the following to our script:</p> <pre><code>for ip in ip_dict['ips']:\n    body = {\n        \"network\": my_network,\n        \"ipv4addr\": ip,\n        'match_client': 'RESERVED',\n        \"comment\": \"created from next available ip routine\"\n    }\n\n    response = wapi.post('fixedaddress', json=body)\n    if response.status_code == 201:\n        print(f'Yay!!!! Reservation Created {response.json()}')\n    else:\n        print(f'error: {response.text}')\n</code></pre>"},{"location":"user_guide/functions/#expand-network","title":"Expand Network","text":"<ol> <li>Retrieve the object reference from the network</li> <li>Expand Network to a /23</li> </ol> <p>To fetch the reference for network container 192.168.2.0/24 from the Grid, we start to create our script with the following:</p> <pre><code>import sys\nfrom ibx_sdk.nios.gift import Gift\n\nwapi = Gift(\n    grid_mgr='infoblox.localdomain',\n    wapi_ver='2.12',\n)\n\nwapi.connect(username='admin', password='infoblox')\n\nmy_network = '192.168.2.0/24'\n\n# Retrieve the reference for my_network\n_ref = wapi.getone(\n    'network',\n    params={\n        'network': my_network,\n        'network_view': 'default'\n    }\n)\n</code></pre> <p>Expand network to 192.168.2.0/23 we add the following to our script:</p> <pre><code>params = {\n    '_function': 'expand_network'\n}\n\n# Create the Body of the request\nbody = {\n    'prefix': 23,\n}\n\n# Get the Network(s)\nresponse = wapi.post(_ref, json=body, params=params)\n</code></pre> <p>Danger</p> <p>This function reduces the subnet masks of a network by joining all networks that fall under it. All the ranges and fixed addresses of the original networks are reparented to the new joined network. Any network containers that fall inside the bounds of the joined network are removed. The member assignments for all the encompassed networks are joined together. The default router, broadcast address, and subnet mask overrided from the joined network, including the ranges and fixed addresses, are all cleaned up.</p>"},{"location":"user_guide/get/","title":"Fetching Objects","text":"<p>Fetching Infoblox objects from the Grid using the NIOS Web RESTful API is without a doubt the most common task for an administrator. When fetching objects from the Grid using WAPI, you will generally make GET request calls. These GET request calls for fetching objects from the Grid generally take the following form:</p> <pre><code>res = wapi.get('&lt;wapi_object&gt;', params={}, **kwargs)\n</code></pre> <p>Tip</p> <p>The Infoblox NIOS WAPI API is fully documented and available online. You can access the API guide by using  the following url path on your Infoblox Grid Manager:</p> <p><code>https://&lt;grid_mgr&gt;/wapidoc</code></p> <p>See the WAPI Guide for details on all objects, properties, functions, and parameters.</p> <p>The Infoblox NIOS Web RESTful API supports Options when performing GET requests to fetch data. A couple of these are shown below:</p> Method Option Description <code>_max_results</code> Maximum number of objects to be returned. If set to a negative number the appliance will return an error when the number of returned objects would exceed the setting. The default is -1000. If this is set to a positive number, the results will be truncated when necessary. <code>_return_fields</code> List of returned fields separated by commas. The use of _return_fields repeatedly is the same as listing several fields with commas. The default is the basic fields of the object."},{"location":"user_guide/get/#basics","title":"Basics","text":"<p>To fetch all <code>network</code> WAPI objects from the Grid, we'd fashion our script like the following:</p> <pre><code>from ibx_sdk.nios.gift import Gift\nfrom ibx_sdk.nios.exceptions import WapiRequestException\n\nwapi = Gift(\n    grid_mgr='infoblox.localdomain',\n    wapi_ver='2.12',\n    ssl_verify='/path/to/certfile'\n)\n\nwapi.connect(username='admin', password='infoblox')\n\n# fetch all networks\nresponse = wapi.get('network')\n</code></pre> <p>Our <code>response</code> above is a Requests response object, and it will contain a number of properties and methods. The ones used most often in working with WAPI data are:</p> property/method Description <code>json()</code> A method returns JSON-encoded object of the result (if the result was JSON encoded) <code>status_code</code> A property representing the HTTP Status Code (200 is OK, 404 is Not Found and so on) <code>text</code> A property which returns the content of the response in unicode <p>We can test the success or failure of the above request by checking for an OK status on the <code>response</code> object this is done like so:</p> <pre><code>response = wapi.get('network')\nif response.status_code == 200:\n    log.info('yay! we succeeded')\nelse:\n    log.error(response.text)\n</code></pre> <p>Let's assume we got a successful <code>response</code> above, to get the JSON-encoded results, all we need to do is unpack the results. Simply do the following:</p> <pre><code>results = response.json()\n</code></pre>"},{"location":"user_guide/get/#query-parameters","title":"Query Parameters","text":"<p>This code will fetch all networks (provided we don't hit the max result set limit!). A JSON response is returned by this request.</p> <p>Note</p> <p>This request is very simple and has no exception handling. If the # of networks in the response  exceeded the <code>_max_results</code> an Exception is raised. The <code>_max_results</code> option defaults to 1000.  When performing the above query, we can optionally pass this option w/ a larger value to avoid the raised Exception.</p> <p>The <code>wapi.get()</code> method signature supports a <code>params</code> option (see the wapi class docs). In order to set <code>_max_results</code> on our previous attempt to fetch all networks, we could adjust this property as follows:</p> <pre><code>response = wapi.get('network', params={'_max_results': 10000})\n</code></pre> <p>The above call now sets the <code>_max_results</code> to 10,000 rows of data.</p>"},{"location":"user_guide/get/#filtering-requests-with-query-parameters","title":"Filtering Requests with Query Parameters","text":"<p>You should always try to optimize your API fetches to your desired result set. Here's a few written examples:</p> <ul> <li>fetch all network objects which have a Grid DHCP Member named dhcp01.example.com assigned</li> <li>fetch all record:a objects from the zone example.com</li> <li>fetch all record:a objects from the example.com zone but from the external DNS view</li> </ul> <p>These are filtered lists of objects instead of simply returning:</p> <ul> <li>fetch all network objects</li> <li>fetch all record:a objects</li> </ul> <p>These would potentially result in exceeding our <code>_max_results</code> value of 1000, not to mention it would return a lot of other data we'd have to sift through to ultimately ignore. So, it's vital to write API requests to be well-thought, filtered, and optimized to your desired result set. This is done by using Query Parameters!</p> <p>To fetch all network objects which have a Grid DHCP Member named dhcp01.example.com we could perform that query as follows:</p> <pre><code>response = wapi.get(\n    'network',\n    params={'member': 'dhcp01.example.com'}\n)\n</code></pre> <p>Behind the scenes, the program would generate an API request that would look something like this:</p> <pre><code>GET https://gm.example.com/wapi/v2.5/network?member=dhcp01.example.com \n</code></pre> <p>The NIOS WAPI would return all network object(s) that were configured w/ the Grid DHCP Member dhcp01.example.com on them.</p> <p>To fetch all record:a objects from the zone example.com, we'd similarly write that as:</p> <pre><code>response = wapi.get(\n    'record:a',\n    params={'zone': 'example.com'}\n)\n</code></pre> <p>Query Parameters can be a set of params and you can create compound filters when requesting. To fetch all record:a from the example.com zone but from the external DNS view, we'd simply add to the previous request the <code>view</code> parameter as follows:</p> <pre><code>response = wapi.get(\n    'record:a',\n    params={\n        'zone': 'example.com',\n        'view': 'external'\n    }\n)\n</code></pre> <p>Tip</p> <p>Not all WAPI object properties can be used in searches. You will need to consult the Infoblox Web RESTful or WAPI Guide on your local Grid Manager by visiting https:///wapidoc for more details."},{"location":"user_guide/logging/","title":"Logging","text":"<p>The logging module <code>ibx_logger.py</code> was written to simplify logging operations by reducing configuration down to a handful of variables.</p> Name Type Description Default console_log bool If True, create and display a colored console logger None logfile_name str Specify the name of a file to log to logfile_mode str Specify the mode for the log file. 'a' for append mode or 'w' for write mode. 'w' level str Specifies the logging level or verbosity. This accepts the following string values 'DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL' 'INFO' num_logs int Specify the number of logs to retain when using a rotating log file handler instead of standard log file handler. None max_size int Specify the maximum size for the log file (in bytes) if you want to use a rotating log file handler instead of a standard log file handler. None <p>The logger is configured when using the <code>init_logger</code> method, and it creates any one of these logging handlers depending on which parameters to you pass to the method:</p> <ul> <li>console logger</li> <li>standard log file handler</li> <li>rotating log file handler</li> </ul>"},{"location":"user_guide/logging/#console-logger","title":"Console Logger","text":"<p>The Console Logger in the <code>ibx_logger</code> is basically a <code>StreamHandler</code> which emits logged messages to sys.stderr. It has been enhanced using the <code>coloredlogs</code> Python module to output logs in color.</p>"},{"location":"user_guide/logging/#console-only-logging","title":"Console-Only Logging","text":"<p>To configure the logger to display console logging for viewing runtime logged events on the console, simply import and run <code>init_console_logger</code>.</p> <pre><code>from ibx_sdk.logger.ibx_logger import init_console_logger\n\nlog = init_console_logger(level='INFO')\nlog.info('This is an informational log message')\n</code></pre>"},{"location":"user_guide/logging/#console-file-logging","title":"Console &amp; File Logging","text":"<p>Configure the console logger with either a standard file or rotating file log handler by passing the <code>console_log</code> to the <code>init_logger</code> function.</p> <pre><code>from ibx_sdk.logger.ibx_logger import init_logger\n\nlog = init_logger(\n    logfile_name='mylog.log',\n    logfile_mode='w',\n    level='INFO',\n    console_log=True\n)\n</code></pre>"},{"location":"user_guide/logging/#standard-file-logger","title":"Standard File Logger","text":"<p>The standard file logger is configured any time <code>init_logger</code> is executed and is controlled by these three variables:</p> <ol> <li>logfile_name (required)</li> <li>logfile_mode (default = 'w')</li> <li>level (default = 'INFO')</li> </ol> <p>The simplest way to get started with the <code>ibx_logger</code> is to run as follows:</p> <pre><code>from ibx_sdk.logger.ibx_logger import init_logger\n\nlog = init_logger(logfile_name='mylog.log')\n</code></pre> <p>The logger will write messages to a file named 'mylog.log' in write mode at level INFO.</p> <p>Tip</p> <p>When <code>logfile_mode</code> is set to 'w' or write mode, the log file set by <code>logfile_name</code> is  overwritten every time the program calls the logger. If you wish to preserve prior messages each time the program/script is executed, simply change <code>logfile_mode</code> to 'a' or append mode. The  logger will open the logfile and append its messages to the end of the file.</p> <p>It is possible to set the logging level two (2) ways:</p> <ul> <li>as part of the initial call to <code>init_logger</code></li> <li>update the current logger by setting <code>set_log_level</code></li> </ul> <pre><code>from ibx_sdk.logger.ibx_logger import init_logger, set_log_level\n\nlog = init_logger(\n    logfile_name='mylog.log',\n    logfile_mode='w',\n    level='INFO'\n)\n\nlog.info('logger level is currently INFO')\nset_log_level(level='DEBUG')\nlog.info('logger level is now currently set at DEBUG')\n</code></pre> <p>In the code above, the level is initially set to 'INFO', but later changed to 'DEBUG'. The ability to do this is handy when crafting CLI scripts. Often times in a CLI script, you want to provide the user an optional way of increasing the verbosity of logging with a <code>--debug</code> option. This can call the <code>set_log_level</code> method to increase logging levels potentially exposing lower level logging output messages that might be in the code.</p>"},{"location":"user_guide/logging/#rotating-file-logger","title":"Rotating File Logger","text":"<p>The ibx_logger.py will create a <code>RotatingFileHandler</code> which supports rotation of disk log files any time the user supplies <code>num_logs</code> and <code>max_size</code> to the <code>init_logger</code> method. If these arguments are not passed to the function, it will only use a <code>FileHandler</code> instance.</p> <p>If you are coding an application for which you expect a significant number of logged messages, and you need to retain message data over a long period of time, configure the <code>ibx_logger</code> as follows:</p> <pre><code>from ibx_sdk.logger.ibx_logger import init_logger\n\nlog = init_logger(\n    logfile_name='mylog.log',\n    logfile_mode='a',\n    num_logs=4,\n    max_size=102400000\n)\n</code></pre> <p>This would save up to 4 files in 100mb increments. The logger would write to mylog.log until it got to the <code>max_size</code>. The logger closes the file, and a new file is opened for writing. This repeats until <code>num_logs</code>. Once <code>num_logs</code> is reached, files become overwritten. The filenames that would result are:</p> <pre><code>mylog.log\nmylog.log.1\nmylog.log.2\nmylog.log.3\nmylog.log.4\n</code></pre>"},{"location":"user_guide/post/","title":"Creating Objects","text":"<p>When using the WAPI to create objects in the Grid, you will need to build up an object as a Python dictionary of attributes and values. The object will likely have some attributes which are required. The dictionary is passed into a POST request as JSON payload.</p> <p>A POST request to create an object in the Grid will generally take the form:</p> <pre><code>response = wapi.post('&lt;wapi_object&gt;', json={body}, **kwargs)\n</code></pre> <p>Tip</p> <p>The Infoblox NIOS WAPI API is fully documented and available online. You can access the API guide by using  the following url path on your Infoblox Grid Manager:</p> <p><code>https://&lt;grid_mgr&gt;/wapidoc</code></p> <p>See the WAPI Guide for details on all objects, properties, functions, and parameters.</p>"},{"location":"user_guide/post/#create-network","title":"Create Network","text":"<pre><code>import sys\nfrom ibx_sdk.nios.gift import Gift\n\nwapi = Gift(\n    grid_mgr='infoblox.localdomain',\n    wapi_ver='2.12',\n)\n\nwapi.connect(username='admin', password='infoblox')\n\n# Create the Body\nbody = {\n    \"network\": \"192.168.1.0/24\",\n    \"comment\": \"this is my test network i'm creating\"\n}\n\n# Create the Netwokr\nresponse = wapi.post('network', json=body)\n</code></pre> <p>Our <code>response</code> above is a Requests response object, and it will contain a number of properties and methods. The ones used most often in working with WAPI data are:</p> property/method Description <code>json()</code> A method returns JSON-encoded object of the result (if the result was JSON encoded) <code>status_code</code> A property representing the HTTP Status Code (200 is OK, 404 is Not Found and so on) <code>text</code> A property which returns the content of the response in unicode <p>We can test the success or failure of the above request by checking for an OK status on the <code>response</code> object this is done like so:</p> <pre><code>if response.status_code != 200:\n    print(f'We hit a snag {response.text}')\n    sys.exit(1)  # Exit program\n</code></pre> <p>When creating objects, the reference of the object will be returned upon the successful creation</p> <pre><code>network/ZG5zLm5ldHdvcmskMTkyLjE2OC4zLjAvMjQvMA:192.168.1.0/24/default\n</code></pre> <p>An unsuccessful call may look like the following:</p> <pre><code>{\n    'Error': 'AdmConDataError: None (IBDataConflictError: IB.Data.Conflict:The network 192.168.1.0/24 already exists.  Select another network.)',\n    'code': 'Client.Ibap.Data.Conflict',\n    'text': 'The network 192.168.1.0/24 already exists.  Select another network.'\n}\n</code></pre>"},{"location":"user_guide/post/#create-host-record","title":"Create Host Record","text":"<pre><code>from ibx_sdk.nios.gift import Gift, WapiRequestException\n\nwapi = Gift(\n    grid_mgr='infoblox.localdomain',\n    wapi_ver='2.12',\n)\n\nwapi.connect(username='admin', password='infoblox')\n\n# Create the Body\nbody = {\n    \"name\": \"my-router.example.com\",\n    \"ipv4addrs\": [\n        {\n            \"ipv4addr\": \"192.168.0.1\"\n\n        }\n    ]\n}\nresponse = wapi.post('record:host', json=body)\n</code></pre> <p>We can test the success or failure of the above request by checking for an OK status on the <code>response</code> object this is done like adding the following to our script:</p> <pre><code>if response.status_code != 200:\n    print(f'We hit a snag {response.text}')\n    sys.exit(1)  # Exit program\n</code></pre> <p>When creating objects, the reference of the object will be returned upon the successful creation</p> <pre><code>record:host/ZG5zLmhvc3QkLl9kZWZhdWx0LmNvbS5leGFtcGxlLm15LXJvdXRlcg:my-router.example.com/Internal%20DNS\n</code></pre> <p>An unsuccessful call may look like the following:</p> <pre><code>{\n    'Error': \"AdmConDataError: None (IBDataConflictError: IB.Data.Conflict:The record 'my-router example.com' already exists.)\", \n    'code': 'Client.Ibap.Data.Conflict', \n    'text': \"The record 'my-rou\n}\n</code></pre>"},{"location":"user_guide/put/","title":"Updating Objects","text":"<p>When using the WAPI to update objects from the Grid, often times you will need to obtain a reference or a list of references to objects, and perform a PUT call on those object references while passing in data you want to update against the reference. Ordinarily it is two (2) calls:</p> <ol> <li> <p>Obtain reference by performing a GET request for the <code>_ref</code> of an object</p> <pre><code>_ref = wapi.getone(&lt;wapi_object&gt;, params, **kwargs)\n</code></pre> </li> <li> <p>Make a PUT request on the <code>_ref</code> of the object</p> <pre><code>response = wapi.put(_ref, **kwargs)\n</code></pre> </li> </ol> <p>Tip</p> <p>The Infoblox NIOS WAPI API is fully documented and available online. You can access the API guide by using the following url path on your Infoblox Grid Manager:</p> <p><code>https://&lt;grid_mgr&gt;/wapidoc</code></p> <p>See the WAPI Guide for details on all objects, properties, functions, and parameters.</p>"},{"location":"user_guide/put/#disable-network-object","title":"Disable Network Object","text":"<ol> <li>Retrieve the object reference from the network</li> <li>Disable the network</li> </ol> <p>Tip</p> <p>The <code>wapi.getone('&lt;wapi_object&gt;', params, **kwargs)</code> method does not return a response object. It will return an  object reference of type string.</p> <p>To fetch the reference for network 192.168.0.0/24 from the Grid, we start to create our script with the following:</p> <pre><code>import sys\nfrom ibx_sdk.nios.gift import Gift, WapiRequestException\n\nwapi = Gift(\n    grid_mgr='infoblox.localdomain',\n    wapi_ver='2.12',\n)\n\nwapi.connect(username='admin', password='infoblox')\n\n_ref = wapi.getone(\n    'network',\n    params={\n        'network': '192.168.0.0/24',\n        'network_view': 'default'\n    }\n)\n</code></pre> <p>To update the network we add the following to our script:</p> <pre><code>body = {\n    'disable': True,\n    'comment': 'Network Disabled through put method'\n\n}\nresponse = wapi.put(_ref, json=body)\n</code></pre> <p>Our <code>response</code> above is a Requests response object, and it will contain a number of properties and methods.</p> <p>The ones used most often in working with WAPI data are:</p> property/method Description <code>json()</code> A method returns JSON-encoded object of the result (if the result was JSON encoded) <code>status_code</code> A property representing the HTTP Status Code (200 is OK, 404 is Not Found and so on) <code>text</code> A property which returns the content of the response in unicode <p>We can test the success or failure of the above request by checking for an OK status on the  <code>response</code> object this is done like adding the following to our script:</p> <pre><code>if response.status_code != 200:\n    print(f'We hit a snag {response.text}')\n    sys.exit(1)  # Exit program\n</code></pre>"},{"location":"user_guide/put/#change-name-on-host-record","title":"Change Name on Host Record","text":"<ol> <li>Retrieve the object reference from the record:host</li> <li>Change its name</li> </ol> <p>To fetch the reference for host my-router.example.com from the Grid, we start to create our script with the following:</p> <pre><code>import sys\nfrom ibx_sdk.nios.gift import Gift, WapiRequestException\n\nwapi = Gift(\n    grid_mgr='infoblox.localdomain',\n    wapi_ver='2.12',\n)\n\nwapi.connect(username='admin', password='infoblox')\n\n_ref = wapi.getone(\n    'record:host',\n    params={\n        'name': 'my-router.example.com',\n        'network_view': 'default'\n    }\n)\n</code></pre> <p>To update the hostname we add the following to our script:</p> <pre><code>body = {\n    'name': 'my-router2.example.com'\n}\nresponse = wapi.put(_ref, json=body)\n</code></pre> <p>We can test the success or failure of the above request by checking for an OK status on the  <code>response</code> object this is done like adding the following to our script:</p> <pre><code>if response.status_code != 200:\n    print(f'We hit a snag {response.text}')\n    sys.exit(1)  # Exit program\n</code></pre>"}]}